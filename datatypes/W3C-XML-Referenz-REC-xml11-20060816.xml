<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE spec SYSTEM "xmlspec.dtd" [
	<!ENTITY base.uri "http://www.w3.org/TR/2006/">
	<!ENTITY maturity.level "REC">
	<!ENTITY doc.shortname "xml11">
	<!ENTITY draft.year "2006">
	<!ENTITY draft.month.name "August">
	<!ENTITY draft.month "08">
	<!ENTITY draft.day "16">
	<!ENTITY iso6.doc.date "&draft.year;&draft.month;&draft.day;">
	<!ENTITY doc.ident "&maturity.level;-&doc.shortname;-&iso6.doc.date;">
	<!ENTITY this.version "&base.uri;&doc.ident;">
	<!ENTITY xml.version "&doc.ident;.xml">
	<!ENTITY review.version "&doc.ident;-review.html">
	<!ENTITY pdf.version "&doc.ident;.pdf">
	<!ENTITY errataloc "http://www.w3.org/XML/xml-V11-2e-errata">
	<!ENTITY preverrataloc "http://www.w3.org/XML/xml-V11-1e-errata">
	<!ENTITY translationloc "http://www.w3.org/2003/03/Translations/byTechnology?technology=&doc.shortname;">
	<!ENTITY impreploc "http://www.w3.org/XML/2006/06/xml11-2e-implementation.html">
	<!ENTITY versionOfXML "1.1">
	<!ENTITY WebSGML "WebSGML Adaptations Annex to ISO 8879">
	<!ENTITY nbsp "&#160;">
	<!ENTITY mdash "&#x2014;">
	<!ENTITY magicents "<code>amp</code>,
<code>lt</code>,
<code>gt</code>,
<code>apos</code>,
<code>quot</code>">
	<!ENTITY may "<phrase diff='chg'>may</phrase>">
	<!ENTITY MAY "<rfc2119>MAY</rfc2119>">
	<!ENTITY % local.common.att "xml:lang    CDATA  #IMPLIED">
]>
<?xml-stylesheet type="text/xsl" href="REC-xml.xsl"?>
<spec w3c-doctype="rec" xml:lang="en">
 <!-- Notes on edit-in-place of Fourth Edition:
- Eliminated all whitespace between <quote> and its contents, usually <code>
- Eliminated a few other spurious spaces in mixed content
- Added 'edited in place' note -->
<!--
Notes on preparation of the Second Edition:

- Worked from http://www.w3.org/XML/xml-V11-1e-errata.
- Last erratum integrated: E22
- Incorporated all errata (barring obsoleted and invalid ones);
  added links to the errata document with <loc role="erratumref">
  elements; used diff="{add|chg|del}" attribute.  This version
  expects that the official HTML output will have diff="del"
  elements suppressed.
- Folded in agreed changes to rfc2119 language
- Updated DTD to version 2.10 and changed default embedded stylesheet
- Added (Second Edition) to title
- Updated various links (prev version, errata, etc.)
- Revised Status section to reflect new status.
- Updated WG roster
-->
	<!-- Final fixups for REC:
Editorial changes from xml-editor messages
Converted all non-ASCII characters to NCRs (this prevents messy problems
resulting from mixed environments.  Please don't change them back!
-->
	<!-- Notes on integration of character normalization definitions for XML 1.1 REC
[2003-12-23 Martin J. D&#xFC;rst]
- Moved 'Character Model' Reference from normative to other, changed to dated.
Made sure it says 'W3C Working Draft', but not sure this is in the right place.

- Added normative reference to UTR #15
- Created new appendix C: Character Normalization Definitions,
copied from Charmod (August 2003 publication) definitions for:

- Unicode encoding form
- legacy encoding
- normalizing transcoder
- character escape
- certified
- Unicode-normalized
- include-normalized
- composing character
- fully normalized

- Changed Section 2.13 to refer to new appendix C.
-->
	<!--
Notes on preparation of the XML 1.1 First Edition:
- Removed all diff="add" and diff="chg" markup
- Removed all elements with diff="del" markup
- Removed all erratum references (locs with role="erratumref")
- Added new editor
- Patched up status section
- Content from XML 1.1 CR
- Made ref to XML 1.0 non-normative
- Appendixes I and J changed for 1.1 First Edition
- New Appendix B has problems, move to Appendix K instead
- Added all accepted and resolved issues
- Backed out overkill resolution of Tobin-02
-->
	<!--
Notes on preparation of the Third Edition:
- Last erratum integrated: E60
- Worked from http://www.w3.org/XML/xml-V10-2e-errata.
- Changed DTD reference to point to V2.4 of XMLspec.
- Added stylesheet PI.
- Revised Status section to reflect new status.
- Incorporated all errata (barring obsoleted and invalid ones);
added links to the errata document with <loc role="erratumref">
elements; used diff="{add|chg|del}" attribute.  This version
expects that the official HTML output will have diff="del"
elements suppressed.
- Added formal markup (rfc2119 element) for RFC 2119 keywords
(MUST, SHOULD, etc.).  This required small modifications to
the text in some cases, like "is" -> "MUST be".
-->
	<!--
Notes on preparation of the Second Edition:
- Worked from http://www.w3.org/XML/xml-19980210-errata.
- Changed DTD reference to point to V2.1 of XMLspec.
- Moved version number from <title> to <version> element and
added "second edition" wording.  Mentioned edition information
in status.
- Removed bgcolor="&cellback;" attributes from all <td>
elements because that attribute is not in the current table model.
- Reversed status and abstract, so that abstract is first, according
to W3C guidelines.
- Changed some <emph>s to <titleref>s in bibliography.
- Changed some <code>s to <at> etc. throughout; where used <attval>,
removed existing <quote>s because the stylesheet produces them.
- Removed some spurious spaces.
- Added affiliation markup to the original member list.
- Added commas between individual <thisver> elements, because
white space is now significant there.
- Moved <eg>s, <scrap>s, and lists outside of <p>s for cleaner HTML
conversion.
- Revised Status section to reflect new status.
- Fixed all titleref hrefs so they get transformed properly; at
next revision, these all probably need to be changed to some
other markup.
- Incorporated all errata (barring obsoleted and invalid ones);
added links to the errata document with <loc role="erratumref">
elements; used diff="{add|chg|del}" attribute.  This version
expects that the official HTML output will have diff="del"
elements suppressed.
- Removed most of the contents of the revisondesc element, which
documented the production of the first edition.  Historians
may find this content in the first (or second edition).
-->
	<header>
		<title>Extensible Markup Language (XML)</title>
		<version>&versionOfXML; (Second Edition)</version>
		<w3c-designation>&doc.ident;</w3c-designation>
		<w3c-doctype>W3C Recommendation</w3c-doctype>
		<pubdate>
			<day>&draft.day;</day>
			<month>&draft.month.name;</month>
			<year>&draft.year;</year>
   <!-- edited in place 29 September 2006 -->
		</pubdate>
		<publoc>
			<loc href="&this.version;">&this.version;</loc>
		</publoc>
		<altlocs>
			<loc href="&xml.version;">XML</loc>
			<!--loc href="&pdf.version;">PDF</loc-->
			<loc href="&review.version;">XHTML with color-coded revision indicators</loc>
		</altlocs>
		<latestloc>
			<loc href="http://www.w3.org/TR/&doc.shortname;">http://www.w3.org/TR/&doc.shortname;</loc>
		</latestloc>
		<prevlocs>
			<loc href="http://www.w3.org/TR/2006/PER-xml11-20060614">http://www.w3.org/TR/2006/PER-xml11-20060614</loc>
		</prevlocs>
		<authlist>
			<author>
				<name>Tim Bray</name>
				<affiliation>Textuality and Netscape</affiliation>
				<email href="mailto:tbray@textuality.com">tbray@textuality.com</email>
			</author>
			<author>
				<name>Jean Paoli</name>
				<affiliation>Microsoft</affiliation>
				<email href="mailto:jeanpa@microsoft.com">jeanpa@microsoft.com</email>
			</author>
			<author>
				<name>C. M. Sperberg-McQueen</name>
				<affiliation>W3C</affiliation>
				<email href="mailto:cmsmcq@w3.org">cmsmcq@w3.org</email>
			</author>
			<author>
				<name>Eve Maler</name>
				<affiliation>Sun Microsystems, Inc.</affiliation>
				<email href="mailto:elm@east.sun.com">eve.maler@east.sun.com</email>
			</author>
			<author>
				<name>Fran√ßois Yergeau</name>
			</author>
			<author>
				<name>John Cowan</name>
				<email href="mailto:cowan@ccil.org">cowan@ccil.org</email>
			</author>
		</authlist>
		<errataloc href="&errataloc;"/>
		<preverrataloc href="&preverrataloc;"/>
		<translationloc href="&translationloc;"/>
		<abstract>
			<p>The Extensible Markup Language (XML) is a subset of SGML that is completely
described in this document. Its goal is to enable generic SGML to be served,
received, and processed on the Web in the way that is now possible with HTML.
XML has been designed for ease of implementation and for interoperability
with both SGML and HTML.</p>
		</abstract>
		<status>
			<p><emph>This section describes the status of this document at the time of its publication.
			Other documents may supersede this document. A list of current W3C publications and the
			latest revision of this technical report can be found in the <loc href="http://www.w3.org/TR/">W3C technical reports index</loc> at
			http://www.w3.org/TR/.</emph></p>

			<p>This document specifies a syntax created by subsetting an existing, widely
used international text processing standard (Standard Generalized Markup Language,
ISO 8879:1986(E) as amended and corrected) for use on the World Wide Web.
It is a product of the <loc href="http://www.w3.org/XML/Core/">XML Core Working Group</loc>
as part of the <loc href="http://www.w3.org/XML/Activity">XML Activity</loc>.</p>
<p>On 29 September 2006 this document was edited in place to remove a number of spurious and potentially misleading spaces.</p>
   <p>The English version of this specification is the only normative version. However,
for translations of this document, see <loc href="&translationloc;">&translationloc;</loc>.</p>
			<p>This document is a <loc href="http://www.w3.org/2005/10/Process-20051014/tr.html#q74">W3C Recommendation</loc>.
			This second edition is <emph>not</emph> a new version of XML. As a convenience to readers,
      it incorporates the changes dictated by the accumulated errata (available at
      <loc href="&preverrataloc;">&preverrataloc;</loc>) to the <loc href="http://www.w3.org/TR/2004/REC-xml11-20040204/">First
      Edition of XML 1.1, dated 4 February 2004</loc>. In addition, the markup introduced to clarify when prescriptive 
      keywords are used
      in the formal sense defined in <bibref ref="rfc2119"/>, has been modified to better match the intent of <bibref ref="rfc2119"/>. 
			This edition supersedes the previous <loc href="http://www.w3.org/TR/2004/REC-xml11-20040204">W3C Recommendation
			of 4 February 2004</loc>.</p>

			<p>Please report errors in this document to the public <loc href="mailto:xml-editor@w3.org">xml-editor@w3.org</loc> mailing list; <loc href="http://lists.w3.org/Archives/Public/xml-editor/">archives</loc> are available. For the convenience of readers,
				an <loc href="&review.version;">XHTML version with color-coded revision indicators</loc> is
				also provided; this version highlights each change due to an erratum published in the
				<loc href="&preverrataloc;">errata list</loc>, together with a link to the particular
				erratum in that list. Most of the errata in the list provide a rationale for the change.
				The errata list for this second edition is available at <loc href="&errataloc;">&errataloc;</loc>.</p>
			
			<p>An implementation report is available at <loc href="&impreploc;">&impreploc;</loc>. A <loc href="http://www.w3.org/XML/Test/">Test Suite</loc> is maintained to help assessing conformance to this specification.</p>

<p>This document has been reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, and is endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material or cited from another document. W3C's role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment. This enhances the functionality and interoperability of the Web.</p>

			<p>This document is governed by the <loc href="http://www.w3.org/TR/2002/NOTE-patent-practice-20020124">24
				January 2002 CPP</loc> as amended by the <loc href="http://www.w3.org/2004/02/05-pp-transition">W3C Patent Policy
				Transition Procedure</loc>. W3C maintains a <loc role="disclosure" href="http://www.w3.org/2002/08/xmlcore-IPR-statements">public list of
				any patent disclosures</loc> made in connection with the deliverables of
				the group; that page also includes instructions for disclosing a patent.
				An individual who has actual knowledge of a patent which the individual
				believes contains <loc href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
				Claim(s)</loc> must disclose the information in accordance with <loc href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
				6 of the W3C Patent Policy</loc>.</p>
		</status>
		<pubstmt>
			<p>Chicago, Vancouver, Mountain View, et al.: World-Wide Web Consortium, XML
Working Group, 1996, 1997, 2000, 2003.</p>
		</pubstmt>
		<sourcedesc>
			<p>Created in electronic form.</p>
		</sourcedesc>
		<langusage>
			<language id="EN">English</language>
			<language id="ebnf">Extended Backus-Naur Form (formal grammar)</language>
		</langusage>
		<revisiondesc>
			<p role="cvsid">$Id: REC-xml11-20060816.xml,v 1.2 2006/09/29 19:02:09 jean-gui Exp $</p>
		</revisiondesc>
	</header>
	<body>
		<div1 id="sec-intro">
			<head>Introduction</head>
			<p>Extensible Markup Language, abbreviated XML, describes a class of data
objects called <termref def="dt-xml-doc">XML documents</termref> and partially
describes the behavior of computer programs which process them. XML is an
application profile or restricted form of SGML, the Standard Generalized Markup
Language <bibref ref="ISO8879"/>. By construction, XML documents are conforming
SGML documents.</p>
			<p>XML documents are made up of storage units called <termref def="dt-entity">entities</termref>,
which contain either parsed or unparsed data. Parsed data is made up of <termref def="dt-character">characters</termref>, some of which form <termref def="dt-chardata">character
data</termref>, and some of which form <termref def="dt-markup">markup</termref>.
Markup encodes a description of the document's storage layout and logical
structure. XML provides a mechanism to impose constraints on the storage layout
and logical structure.</p>
			<p>
				<termdef id="dt-xml-proc" term="XML Processor">A software module called
an <term>XML processor</term> is used to read XML documents and provide access
to their content and structure.</termdef>
				<termdef id="dt-app" term="Application">It
is assumed that an XML processor is doing its work on behalf of another module,
called the <term>application</term>.</termdef> This specification describes
the required behavior of an XML processor in terms of how it must read XML
data and the information it must provide to the application.</p>
			<div2 id="sec-origin-goals">
				<head>Origin and Goals</head>
				<p>XML was developed by an XML Working Group (originally known as the SGML
Editorial Review Board) formed under the auspices of the World Wide Web Consortium
(W3C) in 1996. It was chaired by Jon Bosak of Sun Microsystems with the active
participation of an XML Special Interest Group (previously known as the SGML
Working Group) also organized by the W3C. The membership of the XML Working
Group is given in an appendix. Dan Connolly served as the Working Group's contact with
the W3C.</p>
				<p>The design goals for XML are:</p>
				<olist>
					<item>
						<p>XML shall be straightforwardly usable over the Internet.</p>
					</item>
					<item>
						<p>XML shall support a wide variety of applications.</p>
					</item>
					<item>
						<p>XML shall be compatible with SGML.</p>
					</item>
					<item>
						<p>It shall be easy to write programs which process XML documents.</p>
					</item>
					<item>
						<p>The number of optional features in XML is to be kept to the absolute
minimum, ideally zero.</p>
					</item>
					<item>
						<p>XML documents should be human-legible and reasonably clear.</p>
					</item>
					<item>
						<p>The XML design should be prepared quickly.</p>
					</item>
					<item>
						<p>The design of XML shall be formal and concise.</p>
					</item>
					<item>
						<p>XML documents shall be easy to create.</p>
					</item>
					<item>
						<p>Terseness in XML markup is of minimal importance.</p>
					</item>
				</olist>
				<p>This specification, together with associated standards (Unicode
<bibref ref="Unicode"/> and ISO/IEC 10646 <bibref ref="ISO10646"/>
for characters, Internet RFC 3066 <bibref ref="RFC1766"/> for
language identification tags, ISO 639 <bibref ref="ISO639"/>
for language name codes, and ISO 3166 <bibref ref="ISO3166"/> for
country name codes), provides all the information necessary to
understand XML Version &versionOfXML; and construct computer
programs to process it.</p>
				<p>This version of the XML specification may be distributed freely, as long as
all text and legal notices remain intact.</p>
			</div2>
			<div2 id="sec-terminology">
				<head>Terminology</head>
				<p>The terminology used to describe XML documents is defined in the body of
this specification. The key words <rfc2119>MUST</rfc2119>, <rfc2119>MUST NOT</rfc2119>, <rfc2119>REQUIRED</rfc2119>, <rfc2119>SHALL</rfc2119>, <rfc2119>SHALL NOT</rfc2119>, <rfc2119>SHOULD</rfc2119>, <rfc2119>SHOULD NOT</rfc2119>, <rfc2119>RECOMMENDED</rfc2119>, &MAY;, and <rfc2119>OPTIONAL</rfc2119>, when <rfc2119>EMPHASIZED</rfc2119>, are to be interpreted as described in <bibref ref="rfc2119"/>. In addition, the terms defined in the following list are used in building
those definitions and in describing the actions of an XML processor:<glist>
						<gitem>
							<label>error</label>
							<def>
								<p>
									<termdef id="dt-error" term="Error">A violation of the rules of this specification;
results are undefined. Unless otherwise specified, failure to observe a prescription of this specification indicated by one of the keywords <rfc2119>MUST</rfc2119>, <rfc2119>REQUIRED</rfc2119>, <rfc2119>MUST NOT</rfc2119>, <rfc2119>SHALL</rfc2119> and <rfc2119>SHALL NOT</rfc2119> is an error.  Conforming software &MAY; detect and report an error
and &MAY; recover from it.</termdef>
								</p>
							</def>
						</gitem>
						<gitem>
							<label>fatal error</label>
							<def>
								<p>
									<termdef id="dt-fatal" term="Fatal Error">An error which a conforming <termref def="dt-xml-proc">XML processor</termref>
										<rfc2119>MUST</rfc2119> detect and report to the application.
After encountering a fatal error, the processor &MAY; continue processing the
data to search for further errors and &MAY; report such errors to the application.
In order to support correction of errors, the processor &MAY; make unprocessed
data from the document (with intermingled character data and markup) available
to the application. Once a fatal error is detected, however, the processor
<rfc2119>MUST NOT</rfc2119> continue normal processing (i.e., it <rfc2119>MUST NOT</rfc2119> continue to pass character
data and information about the document's logical structure to the application
in the normal way).</termdef>
								</p>
							</def>
						</gitem>
						<gitem>
							<label>at user option</label>
							<def>
								<p>
									<termdef id="dt-atuseroption" term="At user option">Conforming software
&MAY; or <rfc2119>MUST</rfc2119> (depending on the modal verb in the sentence) behave as described;
if it does, it <rfc2119>MUST</rfc2119> provide users a means to enable or disable the behavior
described.</termdef>
								</p>
							</def>
						</gitem>
						<gitem>
							<label>validity constraint</label>
							<def>
								<p>
									<termdef id="dt-vc" term="Validity constraint">A rule which applies to
all <termref def="dt-valid">valid</termref> XML documents. Violations of validity
constraints are errors; they <rfc2119>MUST</rfc2119>, at user option, be reported by <termref def="dt-validating">validating XML processors</termref>.</termdef>
								</p>
							</def>
						</gitem>
						<gitem>
							<label>well-formedness constraint</label>
							<def>
								<p>
									<termdef id="dt-wfc" term="Well-formedness constraint">A rule which applies
to all <termref def="dt-wellformed">well-formed</termref> XML documents. Violations
of well-formedness constraints are <termref def="dt-fatal">fatal errors</termref>.</termdef>
								</p>
							</def>
						</gitem>
						<gitem>
							<label>match</label>
							<def>
								<p>
									<termdef id="dt-match" term="match">(Of strings or names:) Two strings
or names being compared <phrase diff="del"><!--loc role="erratumref" href="PE148"/-->
											<rfc2119>MUST</rfc2119>
be</phrase>
										<phrase diff="add"><!--loc role="erratumref" href="PE148"/-->are</phrase> identical. Characters with multiple possible
representations in Unicode (e.g. characters with both precomposed and
base+diacritic forms) match only if they have the same representation in both
strings. No
case folding is performed. (Of strings and rules in the grammar:) A string
matches a grammatical production if it belongs to the language generated by
that production. (Of content and content models:) An element matches its declaration
when it conforms in the fashion described in the constraint <specref ref="elementvalid"/>.</termdef>
								</p>
							</def>
						</gitem>
						<gitem>
							<label>for compatibility</label>
							<def>
								<p>
									<termdef id="dt-compat" term="For Compatibility">Marks
a sentence describing a feature of XML included solely to ensure
that XML remains compatible with SGML.</termdef>
								</p>
							</def>
						</gitem>
						<gitem>
							<label>for interoperability</label>
							<def>
								<p>
									<termdef id="dt-interop" term="For interoperability">Marks
a sentence describing a non-binding recommendation included to increase
the chances that XML documents can be processed by the existing installed
base of SGML processors which predate the &WebSGML;.</termdef>
								</p>
							</def>
						</gitem>
					</glist>
				</p>
			</div2>
			<div2 id="sec-xml11">
				<head>Rationale and list of changes for XML 1.1</head>
				<p>The W3C's XML 1.0 Recommendation was first issued in 1998, and
despite the issuance of many errata culminating in a Third Edition
of 2004, has remained (by intention) unchanged with respect to what
is well-formed XML and what is not. This stability has been
extremely useful for interoperability. However, the Unicode
Standard on which XML 1.0 relies for character specifications has
not remained static, evolving from version 2.0 to version 4.0 and
beyond. Characters not present in Unicode 2.0 may already be used
in XML 1.0 character data. However, they are not allowed in XML
names such as element type names, attribute names, enumerated
attribute values, processing instruction targets, and so on. In
addition, some characters that should have been permitted in XML
names were not, due to oversights and inconsistencies in Unicode
2.0.</p>
				<p>The overall philosophy of names has changed since XML 1.0.
Whereas XML 1.0 provided a rigid definition of names, wherein
everything that was not permitted was forbidden, XML 1.1 names are
designed so that everything that is not forbidden (for a specific
reason) is permitted. Since Unicode will continue to grow past
version 4.0, further changes to XML can be avoided by allowing
almost any character, including those not yet assigned, in
names.</p>
				<p>In addition, XML 1.0 attempts to adapt to the line-end
conventions of various modern operating systems, but discriminates
against the conventions used on IBM and IBM-compatible mainframes.
As a result, XML documents on mainframes are not plain text files
according to the local conventions. XML 1.0 documents generated on
mainframes must either violate the local line-end conventions, or
employ otherwise unnecessary translation phases before parsing and
after generation. Allowing straightforward interoperability is
particularly important when data stores are shared between
mainframe and non-mainframe systems (as opposed to being copied
from one to the other). Therefore XML 1.1 adds NEL (#x85) to the
list of line-end characters. For completeness, the Unicode line
separator character, #x2028, is also supported.
</p>
				<p>Finally, there is considerable demand to define a standard representation
of arbitrary Unicode characters in XML documents. Therefore, XML 1.1
allows the use of character references to the control characters #x1 through
#x1F, most of which are forbidden in XML 1.0. For reasons of robustness,
however, these characters still cannot be used directly in documents. In
order to improve the robustness of character encoding detection, the additional
control characters #x7F through #x9F, which were freely allowed in XML 1.0
documents, now must also appear only as character references. (Whitespace
characters are of course exempt.) The minor sacrifice of backward compatibility
is considered not significant. Due to potential problems with APIs,
#x0 is still forbidden both directly and as a character reference.
</p>
				<p>Finally, XML 1.1 defines a set of constraints called "full
normalization" on XML documents, which document creators
<rfc2119>SHOULD</rfc2119> adhere to, and document processors
<rfc2119>SHOULD</rfc2119> verify.  Using fully normalized documents
ensures that identity comparisons of names, attribute values, and
character content can be made correctly by simple binary comparison of
Unicode strings.</p>
				<p>A new XML version, rather than a set of errata to XML 1.0, is
being created because the changes affect the definition of
well-formed documents. XML 1.0 processors must continue to reject
documents that contain new characters in XML names, new line-end
conventions, and references to control characters. The distinction between XML 1.0 and XML 1.1 documents
is indicated by the version number information in the XML
declaration at the start of each document.
</p>
			</div2>
		</div1>
		<!-- &Docs; -->
		<div1 id="sec-documents">
			<head>Documents</head>
			<p>
				<termdef id="dt-xml-doc" term="XML Document"> A data object is an <term>XML
document</term> if it is <termref def="dt-wellformed">well-formed</termref>,
as defined in this specification. <phrase diff="chg"><loc role="erratumref" href="E16"/>In addition, the XML document is</phrase>
					<termref def="dt-valid">valid</termref> if it meets certain further constraints.</termdef>
			</p>
			<p>Each XML document has both a logical and a physical structure. Physically,
the document is composed of units called <termref def="dt-entity">entities</termref>.
An entity &may; <termref def="dt-entref">refer</termref> to other entities to
cause their inclusion in the document. A document begins in a <quote>root</quote>
or <termref def="dt-docent">document entity</termref>. Logically, the document
is composed of declarations, elements, comments, character references, and
processing instructions, all of which are indicated in the document by explicit
markup. The logical and physical structures <rfc2119>MUST</rfc2119> nest properly, as described
in <specref ref="wf-entities"/>.</p>
			<div2 id="sec-well-formed">
				<head>Well-Formed XML Documents</head>
				<p>
					<termdef id="dt-wellformed" term="Well-Formed"> A textual object is a <term>well-formed</term>
XML document if:</termdef>
				</p>
				<olist>
					<item>
						<p>Taken as a whole, it matches the production labeled <nt def="NT-document">document</nt>.</p>
					</item>
					<item>
						<p>It meets all the well-formedness constraints given in this specification.</p>
					</item>
					<item>
						<p>Each of the <termref def="dt-parsedent">parsed entities</termref>
which is referenced directly or indirectly within the document is <termref def="dt-wellformed">well-formed</termref>.</p>
					</item>
				</olist>
				<scrap id="document" lang="ebnf">
					<head>Document</head>
					<prod id="NT-document" num="1">
						<lhs>document</lhs>
						<rhs>
							<phrase diff="add">
								<loc role="erratumref" href="E02"/>(</phrase>
							<nt def="NT-prolog">prolog</nt>
							<nt def="NT-element">element</nt>
							<nt def="NT-Misc">Misc</nt>*<phrase diff="add">
								<loc role="erratumref" href="E02"/>)</phrase>
							<phrase diff="add">
								<loc role="erratumref" href="E01"/>
							</phrase>- <phrase diff="add">
								<loc role="erratumref" href="E02"/>(</phrase>
							<nt def="NT-Char">Char</nt>* <nt def="NT-RestrictedChar">RestrictedChar</nt>
							<phrase diff="add">
								<loc role="erratumref" href="E01"/>
							</phrase>
							<nt def="NT-Char">Char</nt>*<phrase diff="add">
								<loc role="erratumref" href="E02"/>)</phrase>
						</rhs>
					</prod>
				</scrap>
				<p>Matching the <nt def="NT-document">document</nt> production implies that:</p>
				<olist>
					<item>
						<p>It contains one or more <termref def="dt-element">elements</termref>.</p>
					</item>
					<!--* N.B. some readers (notably JC) find the following
paragraph awkward and redundant. I agree it's logically redundant:
it *says* it is summarizing the logical implications of
matching the grammar, and that means by definition it's
logically redundant. I don't think it's rhetorically
redundant or unnecessary, though, so I'm keeping it. It
could however use some recasting when the editors are feeling
stronger. -MSM *-->
					<item>
						<p>
							<termdef id="dt-root" term="Root Element">There is exactly one element,
called the <term>root</term>, or document element, no part of which appears
in the <termref def="dt-content">content</termref> of any other element.</termdef> For
all other elements, if the <termref def="dt-stag">start-tag</termref> is in
the content of another element, the <termref def="dt-etag">end-tag</termref>
is in the content of the same element. More simply stated, the elements,
delimited by start- and end-tags, nest properly within each other.</p>
					</item>
				</olist>
				<p>
					<termdef id="dt-parentchild" term="Parent/Child">As a consequence of this,
for each non-root element <el>C</el> in the document, there is one other element <el>P</el>
in the document such that <el>C</el> is in the content of <el>P</el>, but
is not in the content of any other element that is in the content of <el>P</el>. <el>P</el>
is referred to as the <term>parent</term> of <el>C</el>, and <el>C</el> as
a <term>child</term> of <el>P</el>.</termdef>
				</p>
			</div2>
			<div2 id="charsets">
				<head>Characters</head>
				<p>
					<termdef id="dt-text" term="Text">A parsed entity contains <term>text</term>,
a sequence of <termref def="dt-character">characters</termref>, which may
represent markup or character data.</termdef>
					<termdef id="dt-character" term="Character">A <term>character</term>
is an atomic unit of text as specified by ISO/IEC 10646 <bibref ref="ISO10646"/>. Legal characters are tab, carriage
return, line feed, and the legal characters
of Unicode and ISO/IEC 10646. The
versions of these standards cited in <specref ref="sec-existing-stds"/> were
current at the time this document was prepared. New characters may be added
to these standards by amendments or new editions. Consequently, XML processors
<rfc2119>MUST</rfc2119> accept any character in the range specified for <nt def="NT-Char">Char</nt>.</termdef>
				</p>
				<scrap id="char32" lang="ebnf">
					<head>Character Range</head>
					<prodgroup pcw2="4" pcw4="17.5" pcw5="11">
						<prod id="NT-Char" num="2">
							<lhs>Char</lhs>
							<rhs>[#x1-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]</rhs>
							<com>any Unicode character, excluding the surrogate blocks, FFFE, and FFFF.</com>
						</prod>
						<prod id="NT-RestrictedChar" num="2a">
							<lhs>RestrictedChar</lhs>
							<rhs>[#x1-#x8] | [#xB-#xC] | [#xE-#x1F] | [#x7F-#x84] | [#x86-#x9F]</rhs>
						</prod>
					</prodgroup>
				</scrap>
				<p>The mechanism for encoding character code points into bit patterns &may;
vary from entity to entity. All XML processors <rfc2119>MUST</rfc2119> accept the UTF-8 and UTF-16
encodings of Unicode <bibref ref="Unicode"/>;
the mechanisms for signaling which of the two is in use,
or for bringing other encodings into play, are discussed later, in <specref ref="charencoding"/>.</p>
				<note>
					<p>Document authors are encouraged to avoid
<quote>compatibility characters</quote>, as defined
in Unicode <bibref ref="Unicode"/>.
The characters defined in the following ranges are also
discouraged. They are either control characters or permanently undefined Unicode
characters:</p>
<eg><phrase diff="add"><loc role="erratumref" href="E18"/>[#x1-#x8], [#xB-#xC], [#xE-#x1F], </phrase>[#x7F-#x84], [#x86-#x9F], [#xFDD0-#xFDDF],
[#<phrase diff="add"><loc role="erratumref" href="E04"/>x</phrase>1FFFE-#x1FFFF], [#<phrase diff="add"><loc role="erratumref" href="E04"/>x</phrase>2FFFE-#x2FFFF], [#<phrase diff="add"><loc role="erratumref" href="E04"/>x</phrase>3FFFE-#x3FFFF],
[#<phrase diff="add"><loc role="erratumref" href="E04"/>x</phrase>4FFFE-#x4FFFF], [#<phrase diff="add"><loc role="erratumref" href="E04"/>x</phrase>5FFFE-#x5FFFF], [#<phrase diff="add"><loc role="erratumref" href="E04"/>x</phrase>6FFFE-#x6FFFF],
[#<phrase diff="add"><loc role="erratumref" href="E04"/>x</phrase>7FFFE-#x7FFFF], [#<phrase diff="add"><loc role="erratumref" href="E04"/>x</phrase>8FFFE-#x8FFFF], [#<phrase diff="add"><loc role="erratumref" href="E04"/>x</phrase>9FFFE-#x9FFFF],
[#<phrase diff="add"><loc role="erratumref" href="E04"/>x</phrase>AFFFE-#xAFFFF], [#<phrase diff="add"><loc role="erratumref" href="E04"/>x</phrase>BFFFE-#xBFFFF], [#<phrase diff="add"><loc role="erratumref" href="E04"/>x</phrase>CFFFE-#xCFFFF],
[#<phrase diff="add"><loc role="erratumref" href="E04"/>x</phrase>DFFFE-#xDFFFF], [#<phrase diff="add"><loc role="erratumref" href="E04"/>x</phrase>EFFFE-#xEFFFF], [#<phrase diff="add"><loc role="erratumref" href="E04"/>x</phrase>FFFFE-#xFFFFF],
[#<phrase diff="add"><loc role="erratumref" href="E04"/>x</phrase>10FFFE-#x10FFFF].</eg>
				</note>
				<!--
<p>Regardless of the specific encoding used, any character in
the ISO/IEC 10646 character set may be referred to by the decimal
or hexadecimal equivalent of its UCS-4 code value.
</p>-->
			</div2>
			<div2 id="sec-common-syn">
				<head>Common Syntactic Constructs</head>
				<p>This section defines some symbols used widely in the grammar.</p>
				<p>
					<nt def="NT-S">S</nt> (white space) consists of one or more space (#x20)
characters, carriage returns, line feeds, or tabs.</p>
				<scrap id="white" lang="ebnf">
					<head>White Space</head>
					<prodgroup pcw2="4" pcw4="17.5" pcw5="11">
						<prod id="NT-S" num="3">
							<lhs>S</lhs>
							<rhs>(#x20 | #x9 | #xD | #xA)+</rhs>
						</prod>
					</prodgroup>
				</scrap>
				<note>
					<p>The presence of #xD in the above production is
maintained purely for backward compatibility with the
<loc href="http://www.w3.org/TR/1998/REC-xml-19980210">First Edition</loc>.
As explained in <specref ref="sec-line-ends"/>,
all #xD characters literally present in an XML document
are either removed or replaced by #xA characters before
any other processing is done. The only way to get a #xD character to match this production is to
use a character reference in an entity value literal.</p>
				</note>
				<p>
					<termdef id="dt-name" term="Name">A <term>Name</term> is a token beginning
with a letter or one of a few punctuation characters, and continuing with
letters, digits, hyphens, underscores, colons, or full stops, together known
as name characters.</termdef> Names beginning with the string <quote><code>xml</code></quote>,
or with any string which would match <code>(('X'|'x') ('M'|'m') ('L'|'l'))</code>,
are reserved for standardization in this or future versions of this specification.</p>
				<note>
					<p>The
Namespaces in XML Recommendation <bibref ref="xml-names"/> assigns a meaning
to names containing colon characters. Therefore, authors should not use the
colon in XML names except for namespace purposes, but XML processors must
accept the colon as a name character.</p>
				</note>
				<p>An <nt def="NT-Nmtoken">Nmtoken</nt> (name token) is any mixture of name
characters.</p>
				<p>The first character of a Name <rfc2119>MUST</rfc2119> be a NameStartChar, and any
other characters <rfc2119>MUST</rfc2119> be NameChars; this mechanism is used to
prevent names from beginning with European (ASCII) digits or with
basic combining characters. Almost all characters are permitted in
names, except those which either are or reasonably could be used as
delimiters. The intention is to be inclusive rather than exclusive,
so that writing systems not yet encoded in Unicode can be used in
XML names. See <specref ref="sec-suggested-names"/> for suggestions on the creation of
names.</p>
				<p>Document authors are encouraged to use names which are
meaningful words or combinations of words in natural languages, and
to avoid symbolic or white space characters in names. Note that
COLON, HYPHEN-MINUS, FULL STOP (period), LOW LINE (underscore), and
MIDDLE DOT are explicitly permitted.</p>
				<p>The ASCII symbols and punctuation marks, along with a fairly
large group of Unicode symbol characters, are excluded from names
because they are more useful as delimiters in contexts where XML
names are used outside XML documents; providing this group gives
those contexts hard guarantees about what <emph>cannot</emph> be part of
an XML name. The character #x037E, GREEK QUESTION MARK, is excluded
because when normalized it becomes a semicolon, which could change
the meaning of entity references.</p>
				<scrap lang="ebnf">
					<head>Names and Tokens</head>
					<prod id="NT-NameStartChar" num="4">
						<lhs>NameStartChar</lhs>
						<rhs>":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]</rhs>
					</prod>
					<prod id="NT-NameChar" num="4a">
						<lhs>NameChar</lhs>
						<rhs>
							<nt def="NT-NameStartChar">NameStartChar</nt> | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]</rhs>
					</prod>
					<prod id="NT-Name" num="5">
						<lhs>Name</lhs>
						<rhs>
							<nt def="NT-NameStartChar">NameStartChar</nt> (<nt def="NT-NameChar">NameChar</nt>)*</rhs>
					</prod>
					<prod id="NT-Names" num="6">
						<lhs>Names</lhs>
						<rhs>
							<nt def="NT-Name">Name</nt> (#x20 <nt def="NT-Name">Name</nt>)*</rhs>
					</prod>
					<prod id="NT-Nmtoken" num="7">
						<lhs>Nmtoken</lhs>
						<rhs>(<nt def="NT-NameChar">NameChar</nt>)+</rhs>
					</prod>
					<prod id="NT-Nmtokens" num="8">
						<lhs>Nmtokens</lhs>
						<rhs>
							<nt def="NT-Nmtoken">Nmtoken</nt> (#x20 <nt def="NT-Nmtoken">Nmtoken</nt>)*</rhs>
					</prod>
				</scrap>
				<note>
					<p>The <nt def="NT-Names">Names</nt>
and <nt def="NT-Nmtokens">Nmtokens</nt> productions are used to define the validity
of tokenized attribute values after normalization (see <specref ref="sec-attribute-types"/>).</p>
				</note>
				<p>Literal data is any quoted string not containing the quotation mark used
as a delimiter for that string. Literals are used for specifying the content
of internal entities (<nt def="NT-EntityValue">EntityValue</nt>), the values
of attributes (<nt def="NT-AttValue">AttValue</nt>), and external identifiers
(<nt def="NT-SystemLiteral">SystemLiteral</nt>). Note that a <nt def="NT-SystemLiteral">SystemLiteral</nt>
can be parsed without scanning for markup.</p>
				<scrap lang="ebnf">
					<head>Literals</head>
					<prod id="NT-EntityValue" num="9">
						<lhs>EntityValue</lhs>
						<rhs>'"' ([^%&amp;"] | <nt def="NT-PEReference">PEReference</nt>
| <nt def="NT-Reference">Reference</nt>)* '"' </rhs>
						<rhs>|&nbsp; "'" ([^%&amp;'] | <nt def="NT-PEReference">PEReference</nt> | <nt def="NT-Reference">Reference</nt>)* "'"</rhs>
					</prod>
					<prod id="NT-AttValue" num="10">
						<lhs>AttValue</lhs>
						<rhs>'"' ([^&lt;&amp;"] | <nt def="NT-Reference">Reference</nt>)*
'"' </rhs>
						<rhs>|&nbsp; "'" ([^&lt;&amp;'] | <nt def="NT-Reference">Reference</nt>)*
"'"</rhs>
					</prod>
					<prod id="NT-SystemLiteral" num="11">
						<lhs>SystemLiteral</lhs>
						<rhs>('"' [^"]* '"') |&nbsp;("'" [^']* "'") </rhs>
					</prod>
					<prod id="NT-PubidLiteral" num="12">
						<lhs>PubidLiteral</lhs>
						<rhs>'"' <nt def="NT-PubidChar">PubidChar</nt>* '"'
| "'" (<nt def="NT-PubidChar">PubidChar</nt> - "'")* "'"</rhs>
					</prod>
					<prod id="NT-PubidChar" num="13">
						<lhs>PubidChar</lhs>
						<rhs>#x20 | #xD | #xA |&nbsp;[a-zA-Z0-9] |&nbsp;[-'()+,./:=?;!*#@$_%]</rhs>
					</prod>
				</scrap>
				<note>
					<p>Although
the <nt def="NT-EntityValue">EntityValue</nt> production allows the definition
of a general entity consisting of a single explicit <code>&lt;</code> in the literal
(e.g., <code>&lt;!ENTITY mylt "&lt;"&gt;</code>), it is strongly advised to avoid
this practice since any reference to that entity will cause a well-formedness
error.</p>
				</note>
			</div2>
			<div2 id="syntax">
				<head>Character Data and Markup</head>
				<p>
					<termref def="dt-text">Text</termref> consists of intermingled <termref def="dt-chardata">character data</termref> and markup. <termdef id="dt-markup" term="Markup">
						<term>Markup</term> takes the form of <termref def="dt-stag">start-tags</termref>, <termref def="dt-etag">end-tags</termref>, <termref def="dt-empty">empty-element tags</termref>, <termref def="dt-entref">entity references</termref>, <termref def="dt-charref">character
references</termref>, <termref def="dt-comment">comments</termref>, <termref def="dt-cdsection">CDATA section</termref> delimiters, <termref def="dt-doctype">document
type declarations</termref>, <termref def="dt-pi">processing instructions</termref>, <nt def="NT-XMLDecl">XML declarations</nt>, <nt def="NT-TextDecl">text declarations</nt>,
and any white space that is at the top level of the document entity (that
is, outside the document element and not inside any other markup).</termdef>
				</p>
				<p>
					<termdef id="dt-chardata" term="Character Data">All text that is not markup
constitutes the <term>character data</term> of the document.</termdef>
				</p>
				<p>The ampersand character (&amp;) and the left angle bracket (&lt;) <rfc2119>MUST NOT</rfc2119> appear
in their literal form, except when used as markup delimiters, or
within a <termref def="dt-comment">comment</termref>, a <termref def="dt-pi">processing
instruction</termref>, or a <termref def="dt-cdsection">CDATA section</termref>.
<!-- FINAL EDIT: restore internal entity decl or leave it out. -->
If they are needed elsewhere, they <rfc2119>MUST</rfc2119> be <termref def="dt-escape">escaped</termref>
using either <termref def="dt-charref">numeric character references</termref>
or the strings <quote><code>&amp;amp;</code></quote> and <quote><code>&amp;lt;</code></quote>
respectively. The right angle bracket (>) &may; be represented using the string <quote><code>&amp;gt;</code></quote>,
and <rfc2119>MUST</rfc2119>, <termref def="dt-compat">for compatibility</termref>, be escaped
using either <quote><code>&amp;gt;</code></quote> or a character reference when it
appears in the string <quote><code>]]&gt;</code></quote> in content, when
that string is not marking the end of a <termref def="dt-cdsection">CDATA
section</termref>.</p>
				<p>In the content of elements, character data is any string of characters
which does not contain the start-delimiter of any markup or the
CDATA-section-close delimiter,
<quote><code>]]&gt;</code></quote>.
In a CDATA section,
character data is any string of characters not including the CDATA-section-close
delimiter.</p>
				<p>To allow attribute values to contain both single and double quotes, the
apostrophe or single-quote character (') &may; be represented as <quote><code>&amp;apos;</code></quote>,
and the double-quote character (") as <quote><code>&amp;quot;</code></quote>.</p>
				<scrap lang="ebnf">
					<head>Character Data</head>
					<prod id="NT-CharData" num="14">
						<lhs>CharData</lhs>
						<rhs>[^&lt;&amp;]* - ([^&lt;&amp;]* ']]&gt;' [^&lt;&amp;]*)</rhs>
					</prod>
				</scrap>
			</div2>
			<div2 id="sec-comments">
				<head>Comments</head>
				<p>
					<termdef id="dt-comment" term="Comment">
						<term>Comments</term> &may; appear
anywhere in a document outside other <termref def="dt-markup">markup</termref>;
in addition, they &may; appear within the document type declaration at places
allowed by the grammar. They are not part of the document's <termref def="dt-chardata">character
data</termref>; an XML processor &MAY;, but need not, make it possible for an
application to retrieve the text of comments. <termref def="dt-compat">For
compatibility</termref>, the string <quote><code>--</code></quote> (double-hyphen)
<rfc2119>MUST NOT</rfc2119> occur within comments.</termdef> Parameter
entity references <rfc2119>MUST NOT</rfc2119> be recognized within comments.</p>
				<scrap lang="ebnf">
					<head>Comments</head>
					<prod id="NT-Comment" num="15">
						<lhs>Comment</lhs>
						<rhs>'&lt;!--' ((<nt def="NT-Char">Char</nt> - '-') | ('-'
(<nt def="NT-Char">Char</nt> - '-')))* '--&gt;'</rhs>
					</prod>
				</scrap>
				<p>An example of a comment:</p>
				<eg>&lt;!-- declarations for &lt;head&gt; &amp; &lt;body&gt; --&gt;</eg>
				<p>Note
that the grammar does not allow a comment ending in <code>---&gt;</code>. The
following example is <emph>not</emph> well-formed.</p>
				<eg>&lt;!-- B+, B, or B---&gt;</eg>
			</div2>
			<div2 id="sec-pi">
				<head>Processing Instructions</head>
				<p>
					<termdef id="dt-pi" term="Processing instruction">
						<term>Processing instructions</term>
(PIs) allow documents to contain instructions for applications.</termdef>
				</p>
				<scrap lang="ebnf">
					<head>Processing Instructions</head>
					<prod id="NT-PI" num="16">
						<lhs>PI</lhs>
						<rhs>'&lt;?' <nt def="NT-PITarget">PITarget</nt> (<nt def="NT-S">S</nt>
(<nt def="NT-Char">Char</nt>* - (<nt def="NT-Char">Char</nt>* '?>' <nt def="NT-Char">Char</nt>*)))? '?>'</rhs>
					</prod>
					<prod id="NT-PITarget" num="17">
						<lhs>PITarget</lhs>
						<rhs>
							<nt def="NT-Name">Name</nt> - (('X' | 'x') ('M' |
'm') ('L' | 'l'))</rhs>
					</prod>
				</scrap>
				<p>PIs are not part of the document's <termref def="dt-chardata">character
data</termref>, but <rfc2119>MUST</rfc2119> be passed through to the application. The PI begins
with a target (<nt def="NT-PITarget">PITarget</nt>) used to identify the application
to which the instruction is directed. The target names <quote><code>XML</code></quote>, <quote><code>xml</code></quote>,
and so on are reserved for standardization in this or future versions of this
specification. The XML <termref def="dt-notation">Notation</termref> mechanism
&may; be used for formal declaration of PI targets. Parameter
entity references <rfc2119>MUST NOT</rfc2119> be recognized within processing instructions.</p>
			</div2>
			<div2 id="sec-cdata-sect">
				<head>CDATA Sections</head>
				<p>
					<termdef id="dt-cdsection" term="CDATA Section">
						<term>CDATA sections</term> &may; occur anywhere character data may occur; they are used to escape blocks
of text containing characters which would otherwise be recognized as markup.
CDATA sections begin with the string <quote><code>&lt;![CDATA[</code></quote>
and end with the string <quote><code>]]&gt;</code></quote>:</termdef>
				</p>
				<scrap lang="ebnf">
					<head>CDATA Sections</head>
					<prod id="NT-CDSect" num="18">
						<lhs>CDSect</lhs>
						<rhs>
							<nt def="NT-CDStart">CDStart</nt>
							<nt def="NT-CData">CData</nt>
							<nt def="NT-CDEnd">CDEnd</nt>
						</rhs>
					</prod>
					<prod id="NT-CDStart" num="19">
						<lhs>CDStart</lhs>
						<rhs>'&lt;![CDATA['</rhs>
					</prod>
					<prod id="NT-CData" num="20">
						<lhs>CData</lhs>
						<rhs>(<nt def="NT-Char">Char</nt>* - (<nt def="NT-Char">Char</nt>*
']]&gt;' <nt def="NT-Char">Char</nt>*)) </rhs>
					</prod>
					<prod id="NT-CDEnd" num="21">
						<lhs>CDEnd</lhs>
						<rhs>']]&gt;'</rhs>
					</prod>
				</scrap>
				<p>Within a CDATA section, only the <nt def="NT-CDEnd">CDEnd</nt> string is
recognized as markup, so that left angle brackets and ampersands may occur
in their literal form; they need not (and cannot) be escaped using <quote><code>&amp;lt;</code></quote>
and <quote><code>&amp;amp;</code></quote>. CDATA sections cannot nest.</p>
				<p>An example of a CDATA section, in which <quote><code>&lt;greeting&gt;</code></quote>
and <quote><code>&lt;/greeting&gt;</code></quote> are recognized as <termref def="dt-chardata">character data</termref>, not <termref def="dt-markup">markup</termref>:</p>
				<eg>&lt;![CDATA[&lt;greeting&gt;Hello, world!&lt;/greeting&gt;]]&gt; </eg>
			</div2>
			<div2 id="sec-prolog-dtd">
				<head>Prolog and Document Type Declaration</head>
				<p>
					<termdef id="dt-xmldecl" term="XML Declaration">XML 1.1 documents <rfc2119>MUST</rfc2119>
begin with an <term>XML declaration</term> which specifies the version of
XML being used.</termdef> For example, the following is a complete XML 1.1 document, <termref def="dt-wellformed">well-formed</termref> but not <termref def="dt-valid">valid</termref>:</p>
				<eg><![CDATA[<?xml version="1.1"?>
<greeting>Hello, world!</greeting> ]]></eg>
				<p>but the following is an XML 1.0 document because it
does not have an XML declaration:</p>
				<eg><![CDATA[<greeting>Hello, world!</greeting>]]></eg>
				<p>The function of the markup in an XML document is to describe its storage and
logical structure and to associate attribute
name-value pairs with its logical structures. XML provides a mechanism, the
<termref def="dt-doctype">document
type declaration</termref>, to define constraints on the logical structure
and to support the use of predefined storage units. <termdef id="dt-valid" term="Validity">An XML document is <term>valid</term> if it has an associated
document type declaration and if the document complies with the constraints
expressed in it.</termdef>
				</p>
				<p>The document type declaration <rfc2119>MUST</rfc2119> appear before the first <termref def="dt-element">element</termref>
in the document.</p>
				<scrap id="xmldoc" lang="ebnf">
					<head>Prolog</head>
					<prodgroup pcw2="6" pcw4="17.5" pcw5="9">
						<prod id="NT-prolog" num="22">
							<lhs>prolog</lhs>
							<rhs>
								<nt def="NT-XMLDecl">XMLDecl</nt>
								<nt def="NT-Misc">Misc</nt>*
(<nt def="NT-doctypedecl">doctypedecl</nt>
								<nt def="NT-Misc">Misc</nt>*)?</rhs>
						</prod>
						<prod id="NT-XMLDecl" num="23">
							<lhs>XMLDecl</lhs>
							<rhs>'&lt;?xml' <nt def="NT-VersionInfo">VersionInfo</nt>
								<nt def="NT-EncodingDecl">EncodingDecl</nt>? <nt def="NT-SDDecl">SDDecl</nt>? <nt def="NT-S">S</nt>? '?>'</rhs>
						</prod>
						<prod id="NT-VersionInfo" num="24">
							<lhs>VersionInfo</lhs>
							<rhs>
								<nt def="NT-S">S</nt> 'version' <nt def="NT-Eq">Eq</nt>
("'" <nt def="NT-VersionNum">VersionNum</nt> "'" | '"' <nt def="NT-VersionNum">VersionNum</nt>
'"')</rhs>
						</prod>
						<prod id="NT-Eq" num="25">
							<lhs>Eq</lhs>
							<rhs>
								<nt def="NT-S">S</nt>? '=' <nt def="NT-S">S</nt>?</rhs>
						</prod>
						<prod id="NT-VersionNum" num="26">
							<lhs>VersionNum</lhs>
							<rhs>'&versionOfXML;'</rhs>
						</prod>
						<prod id="NT-Misc" num="27">
							<lhs>Misc</lhs>
							<rhs>
								<nt def="NT-Comment">Comment</nt> | <nt def="NT-PI">PI</nt>
| <nt def="NT-S">S</nt>
							</rhs>
						</prod>
					</prodgroup>
				</scrap>
				<p>
					<termdef id="dt-doctype" term="Document Type Declaration">The XML <term>document
type declaration</term> contains or points to <termref def="dt-markupdecl">markup
declarations</termref> that provide a grammar for a class of documents. This
grammar is known as a document type definition, or <term>DTD</term>. The document
type declaration can point to an external subset (a special kind of <termref def="dt-extent">external entity</termref>) containing markup declarations,
or can contain the markup declarations directly in an internal subset, or
can do both. The DTD for a document consists of both subsets taken together.</termdef>
				</p>
				<p>
					<termdef id="dt-markupdecl" term="markup declaration"> A <term>markup declaration</term>
is an <termref def="dt-eldecl">element type declaration</termref>, an <termref def="dt-attdecl">attribute-list declaration</termref>, an <termref def="dt-entdecl">entity
declaration</termref>, or a <termref def="dt-notdecl">notation declaration</termref>.</termdef>
These declarations &may; be contained in whole or in part within <termref def="dt-PE">parameter
entities</termref>, as described in the well-formedness and validity constraints
below. For further
information, see <specref ref="sec-physical-struct"/>.</p>
				<scrap id="dtd" lang="ebnf">
					<head>Document Type Definition</head>
					<prodgroup pcw2="6" pcw4="17.5" pcw5="9">
						<prod id="NT-doctypedecl" num="28">
							<lhs>doctypedecl</lhs>
							<rhs>'&lt;!DOCTYPE' <nt def="NT-S">S</nt>
								<nt def="NT-Name">Name</nt>
(<nt def="NT-S">S</nt>
								<nt def="NT-ExternalID">ExternalID</nt>)? <nt def="NT-S">S</nt>?
('[' <nt def="NT-intSubset">intSubset</nt> ']' <nt def="NT-S">S</nt>?)? '&gt;'</rhs>
							<vc def="vc-roottype"/>
							<wfc def="ExtSubset"/>
						</prod>
						<prod id="NT-DeclSep" num="28a">
							<lhs>DeclSep</lhs>
							<rhs>
								<nt def="NT-PEReference">PEReference</nt> | <nt def="NT-S">S</nt>
							</rhs>
							<wfc def="PE-between-Decls"/>
						</prod>
						<prod id="NT-intSubset" num="28b">
							<lhs>intSubset</lhs>
							<rhs>(<nt def="NT-markupdecl">markupdecl</nt> | <nt def="NT-DeclSep">DeclSep</nt>)*</rhs>
						</prod>
						<prod id="NT-markupdecl" num="29">
							<lhs>markupdecl</lhs>
							<rhs>
								<nt def="NT-elementdecl">elementdecl</nt> | <nt def="NT-AttlistDecl">AttlistDecl</nt> | <nt def="NT-EntityDecl">EntityDecl</nt>
| <nt def="NT-NotationDecl">NotationDecl</nt> | <nt def="NT-PI">PI</nt> | <nt def="NT-Comment">Comment</nt>
							</rhs>
							<vc def="vc-PEinMarkupDecl"/>
							<wfc def="wfc-PEinInternalSubset"/>
						</prod>
					</prodgroup>
				</scrap>
				<p>Note
that it is possible to construct a well-formed document containing a <nt def="NT-doctypedecl">doctypedecl</nt>
that neither points to an external subset nor contains an internal subset.</p>
				<p>The markup declarations &may; be made up in whole or in part of the <termref def="dt-repltext">replacement text</termref> of <termref def="dt-PE">parameter
entities</termref>. The productions later in this specification for individual
nonterminals (<nt def="NT-elementdecl">elementdecl</nt>, <nt def="NT-AttlistDecl">AttlistDecl</nt>,
and so on) describe the declarations <emph>after</emph> all the parameter
entities have been <termref def="dt-include">included</termref>.</p>
				<p>Parameter
entity references are recognized anywhere in the DTD (internal and external
subsets and external parameter entities), except in literals, processing instructions,
comments, and the contents of ignored conditional sections (see <specref ref="sec-condition-sect"/>).
They are also recognized in entity value literals. The use of parameter entities
in the internal subset is restricted as described below.</p>
				<vcnote id="vc-roottype">
					<head>Root Element Type</head>
					<p>The <nt def="NT-Name">Name</nt>
in the document type declaration <rfc2119>MUST</rfc2119> match the element type of the <termref def="dt-root">root element</termref>.</p>
				</vcnote>
				<vcnote id="vc-PEinMarkupDecl">
					<head>Proper Declaration/PE Nesting</head>
					<p>Parameter-entity <termref def="dt-repltext">replacement text</termref>
						<rfc2119>MUST</rfc2119> be properly nested with markup declarations. That is to say, if either
the first character or the last character of a markup declaration (<nt def="NT-markupdecl">markupdecl</nt>
above) is contained in the replacement text for a <termref def="dt-PERef">parameter-entity
reference</termref>, both <rfc2119>MUST</rfc2119> be contained in the same replacement text.</p>
				</vcnote>
				<wfcnote id="wfc-PEinInternalSubset">
					<head>PEs in Internal Subset</head>
					<p>In
the internal DTD subset, <termref def="dt-PERef">parameter-entity references</termref>
						<rfc2119>MUST NOT</rfc2119> occur within markup declarations; they &may; occur where markup declarations can occur.
(This does not apply to references that occur in external parameter entities
or to the external subset.)</p>
				</wfcnote>
				<wfcnote id="ExtSubset">
					<head>External Subset</head>
					<p>The external subset, if any, <rfc2119>MUST</rfc2119> match the production for <nt def="NT-extSubset">extSubset</nt>.</p>
				</wfcnote>
				<wfcnote id="PE-between-Decls">
					<head>PE Between Declarations</head>
					<p>The replacement text of a parameter entity reference
in a <nt def="NT-DeclSep">DeclSep</nt>
						<rfc2119>MUST</rfc2119> match the production <nt def="NT-extSubsetDecl">extSubsetDecl</nt>.</p>
				</wfcnote>
				<p>Like the internal subset, the external subset and any external parameter
entities referenced
in a <nt def="NT-DeclSep">DeclSep</nt>
					<rfc2119>MUST</rfc2119> consist of a series of
complete markup declarations of the types allowed by the non-terminal symbol <nt def="NT-markupdecl">markupdecl</nt>, interspersed with white space or <termref def="dt-PERef">parameter-entity references</termref>. However, portions of
the contents of the external subset or of these
external parameter entities &may; conditionally be ignored by using the <termref def="dt-cond-section">conditional section</termref> construct; this is not
allowed in the internal subset but is
allowed in external parameter entities referenced in the internal subset.</p>
				<scrap id="ext-Subset" lang="ebnf">
					<head>External Subset</head>
					<prodgroup pcw2="6" pcw4="17.5" pcw5="9">
						<prod id="NT-extSubset" num="30">
							<lhs>extSubset</lhs>
							<rhs>
								<nt def="NT-TextDecl">TextDecl</nt>? <nt def="NT-extSubsetDecl">extSubsetDecl</nt>
							</rhs>
						</prod>
						<prod id="NT-extSubsetDecl" num="31">
							<lhs>extSubsetDecl</lhs>
							<rhs>( <nt def="NT-markupdecl">markupdecl</nt> | <nt def="NT-conditionalSect">conditionalSect</nt> | <nt def="NT-DeclSep">DeclSep</nt>)*</rhs>
						</prod>
					</prodgroup>
				</scrap>
				<p>The external subset and external parameter entities also differ from the
internal subset in that in them, <termref def="dt-PERef">parameter-entity
references</termref> are permitted <emph>within</emph> markup declarations,
not only <emph>between</emph> markup declarations.</p>
				<p>An example of an XML document with a document type declaration:</p>
				<eg><![CDATA[<?xml version="1.1"?>
<!DOCTYPE greeting SYSTEM "hello.dtd">
<greeting>Hello, world!</greeting> ]]></eg>
				<p>The <termref def="dt-sysid">system identifier</termref>
					<quote><code>hello.dtd</code></quote>
gives the address (a URI reference) of a DTD for the document.</p>
				<p>The declarations can also be given locally, as in this example:</p>
				<eg><![CDATA[<?xml version="1.1" encoding="UTF-8" ?>
<!DOCTYPE greeting [
<!ELEMENT greeting (#PCDATA)>
]>
<greeting>Hello, world!</greeting>]]></eg>
				<p>If both the external and internal subsets are used, the internal subset
<rfc2119>MUST</rfc2119> be considered to occur before the external subset. <!-- 'is considered to'? boo. whazzat mean? -->
This has the effect that entity and attribute-list declarations in the internal
subset take precedence over those in the external subset.</p>
				<p>
					<phrase diff="del">
						<loc role="erratumref" href="E15"/>XML 1.1 processors <rfc2119>SHOULD</rfc2119> accept XML 1.0
documents as well. </phrase>If a document is well-formed or valid XML 1.0, and provided it
does not contain any control characters
in the range [#x7F-#x9F] other than as character escapes, it may be
made well-formed or valid XML 1.1 respectively simply by changing the
version number.</p>
			</div2>
			<div2 id="sec-rmd">
				<head>Standalone Document Declaration</head>
				<p>Markup declarations can affect the content of the document, as passed from
an <termref def="dt-xml-proc">XML processor</termref> to an application; examples
are attribute defaults and entity declarations. The standalone document declaration,
which &may; appear as a component of the XML declaration, signals whether or
not there are such declarations which appear external to the <termref def="dt-docent">document
entity</termref>
or in parameter entities. <termdef id="dt-extmkpdecl" term="External Markup Declaration">An <term>external
markup declaration</term> is defined as a markup declaration occurring in
the external subset or in a parameter entity (external or internal, the latter
being included because non-validating processors are not required to read
them).</termdef>
				</p>
				<scrap id="fulldtd" lang="ebnf">
					<head>Standalone Document Declaration</head>
					<prodgroup pcw2="4" pcw4="19.5" pcw5="9">
						<prod id="NT-SDDecl" num="32">
							<lhs>SDDecl</lhs>
							<rhs>
								<phrase diff="chg">
									<loc role="erratumref" href="E10"/>
									<nt def="NT-S">S</nt>
								</phrase> 'standalone' <nt def="NT-Eq">Eq</nt>
(("'" ('yes' | 'no') "'") | ('"' ('yes' | 'no') '"')) </rhs>
							<vc def="vc-check-rmd"/>
						</prod>
					</prodgroup>
				</scrap>
				<p>In a standalone document declaration, the value <attval>yes</attval> indicates
that there are no <termref def="dt-extmkpdecl">external markup declarations</termref> which
affect the information passed from the XML processor to the application. The
value <attval>no</attval> indicates that there are or may be such external
markup declarations. Note that the standalone document declaration only denotes
the presence of external <emph>declarations</emph>; the presence, in a document,
of references to external <emph>entities</emph>, when those entities are internally
declared, does not change its standalone status.</p>
				<p>If there are no external markup declarations, the standalone document declaration
has no meaning. If there are external markup declarations but there is no
standalone document declaration, the value <attval>no</attval> is assumed.</p>
				<p>Any XML document for which <code>standalone="no"</code> holds can be converted
algorithmically to a standalone document, which may be desirable for some
network delivery applications.</p>
				<vcnote id="vc-check-rmd">
					<head>Standalone Document Declaration</head>
					<p>The
standalone document declaration <rfc2119>MUST</rfc2119> have the value <attval>no</attval> if
any external markup declarations contain declarations of:</p>
					<ulist>
						<item>
							<p>attributes with <termref def="dt-default">default</termref> values,
if elements to which these attributes apply appear in the document without
specifications of values for these attributes, or</p>
						</item>
						<item>
							<p>entities (other than &magicents;), if <termref def="dt-entref">references</termref>
to those entities appear in the document, or</p>
						</item>
						<item>
							<p>attributes with
tokenized types, where the
attribute appears in the document with a value such that
<titleref href="#AVNormalize">normalization</titleref>
will produce a different value from that which would be produced
in the absence of the declaration, or</p>
						</item>
						<item>
							<p>element types with <termref def="dt-elemcontent">element content</termref>,
if white space occurs directly within any instance of those types.</p>
						</item>
					</ulist>
				</vcnote>
				<p>An example XML declaration with a standalone document declaration:</p>
				<eg>&lt;?xml version="&versionOfXML;" standalone='yes'?&gt;</eg>
			</div2>
			<div2 id="sec-white-space">
				<head>White Space Handling</head>
				<p>In editing XML documents, it is often convenient to use <quote>white space</quote>
(spaces, tabs, and blank lines)
to set apart the markup for greater readability. Such white space is typically
not intended for inclusion in the delivered version of the document. On the
other hand, <quote>significant</quote> white space that should be preserved
in the delivered version is common, for example in poetry and source code.</p>
				<p>An <termref def="dt-xml-proc">XML processor</termref>
					<rfc2119>MUST</rfc2119> always pass
all characters in a document that are not markup through to the application.
A <termref def="dt-validating"> validating XML processor</termref>
					<rfc2119>MUST</rfc2119> also
inform the application which of these characters constitute white space appearing
in <termref def="dt-elemcontent">element content</termref>.</p>
				<p>A special <termref def="dt-attr">attribute</termref> named <att>xml:space</att> &may; be attached to an element to signal an intention that in that element,
white space should be preserved by applications. In valid documents, this
attribute, like any other, <rfc2119>MUST</rfc2119> be <termref def="dt-attdecl">declared</termref>
if it is used. When declared, it <rfc2119>MUST</rfc2119> be given as an <termref def="dt-enumerated">enumerated
type</termref> whose values
are one or both of <attval>default</attval> and <attval>preserve</attval>.
For example:</p>
				<eg><![CDATA[<!ATTLIST poem  xml:space (default|preserve) 'preserve'>]]>
&lt;!ATTLIST pre xml:space (preserve) #FIXED 'preserve'&gt;</eg>
				<p>The value <attval>default</attval> signals that applications' default white-space
processing modes are acceptable for this element; the value <attval>preserve</attval>
indicates the intent that applications preserve all the white space. This
declared intent is considered to apply to all elements within the content
of the element where it is specified, unless overridden with
another instance of the <att>xml:space</att> attribute. This specification does not give meaning to any value of <att>xml:space</att> other than <attval>default</attval> and <attval>preserve</attval>. It is an error for other values to be specified; the XML processor &MAY; report the error or &MAY; recover by ignoring the attribute specification or by reporting the (erroneous) value to the application. Applications may ignore or reject erroneous values.</p>
				<p>The <termref def="dt-root">root element</termref> of any document is considered
to have signaled no intentions as regards application space handling, unless
it provides a value for this attribute or the attribute is declared with a
default value.</p>
			</div2>
			<div2 id="sec-line-ends">
				<head>End-of-Line Handling</head>
				<p>XML <termref def="dt-parsedent">parsed entities</termref> are often stored
in computer files which, for editing convenience, are organized into lines.
These lines are typically separated by some combination of the characters
CARRIAGE RETURN (#xD) and LINE FEED (#xA).</p>
				<p>To
simplify the tasks of <termref def="dt-app">applications</termref>, the
<termref def="dt-xml-proc">XML
processor</termref>
					<rfc2119>MUST</rfc2119> behave as if it normalized all line breaks in external parsed
entities (including the document entity) on input, before parsing, by translating
all of the following to a single #xA character:</p>
				<olist>
					<item>
						<p>the two-character sequence #xD #xA</p>
					</item>
					<item>
						<p>the two-character sequence #xD #x85</p>
					</item>
					<item>
						<p>the single character #x85</p>
					</item>
					<item>
						<p>the single character #x2028</p>
					</item>
					<item>
						<p>any #xD character that is not immediately followed by #xA or #x85.</p>
					</item>
				</olist>
				<p>  The characters #x85 and #x2028 cannot be reliably recognized and
translated until an entity's encoding declaration (if present) has
been read.  Therefore, it is a fatal error to use them within the XML
declaration or text declaration.
</p>
			</div2>
			<div2 id="sec-lang-tag">
				<head>Language Identification</head>
				<p>In document processing, it is often useful to identify the natural or formal
language in which the content is written. A special <termref def="dt-attr">attribute</termref>
named <att>xml:lang</att> &may; be inserted in documents to specify the language
used in the contents and attribute values of any element in an XML document.
In valid documents, this attribute, like any other, <rfc2119>MUST</rfc2119> be <termref def="dt-attdecl">declared</termref>
if it is used. The
values of the attribute are language identifiers as defined by <bibref ref="RFC1766"/>, <titleref>Tags
for the Identification of Languages</titleref>, or its successor; in addition, the empty string &may; be specified.</p>
				<p>(Productions 33 through 38 have been removed.)</p>
				<p>For example:</p>
				<eg><![CDATA[<p xml:lang="en">The quick brown fox jumps over the lazy dog.</p>
<p xml:lang="en-GB">What colour is it?</p>
<p xml:lang="en-US">What color is it?</p>
<sp who="Faust" desc='leise' xml:lang="de">
<l>Habe nun, ach! Philosophie,</l>
<l>Juristerei, und Medizin</l>
<l>und leider auch Theologie</l>
<l>durchaus studiert mit hei&#xDF;em Bem&#xFC;h'n.</l>
</sp>]]></eg>
				<!--<p>The xml:lang value is considered to apply both to the contents of an
element and
(unless otherwise via attribute default values) to the
values of all of its attributes with free-text (CDATA) values. -->
				<p>The <phrase diff="chg">
						<loc role="erratumref" href="E03"/>language specified by</phrase>
					<att>xml:lang</att>
					<phrase diff="del">
						<loc role="erratumref" href="E03"/>is considered to </phrase>
					<phrase diff="chg">
						<loc role="erratumref" href="E03"/>applies</phrase>
     to <phrase diff="del">
						<loc role="erratumref" href="E03"/>all attributes and content of</phrase> the element where it is specified<phrase diff="add">
						<loc role="erratumref" href="E03"/>
         (including the values of its attributes), and  to all elements in its content</phrase> unless
     overridden with <phrase diff="chg">
						<loc role="erratumref" href="E03"/>another</phrase> instance of <att>xml:lang</att><phrase diff="del">
						<loc role="erratumref" href="E03"/> on another element within
     that content</phrase>. In particular, the empty value of <att>xml:lang</att> is used on an element B to override
         a specification of <att>xml:lang</att> on an enclosing element A, without specifying another language. Within B,
         it is considered that there is no language information available, just as if <att>xml:lang</att> had not been specified
         on B or any of its ancestors.<phrase diff="add">
						<loc role="erratumref" href="E03"/> Applications determine which of an element's attribute values
     and which parts of its character content, if any, are treated as language-dependent values described by <att>xml:lang</att>.</phrase></p>
				<!--
If no
value is specified for xml:lang on an element, and no default value is
defined for it in the DTD, then the xml:lang attribute of any element
takes the same value it has in the parent element, if any. The two
technical terms in the following example both have the same effective
value for xml:lang:
<p xml:lang="en">Here the keywords are
<term xml:lang="en">shift</term> and
<term>reduce</term>. ...</p>
The application, not the XML processor, is responsible for this '
inheritance' of attribute values.
-->
				<note>
					<p>Language information may also be provided by external transport protocols (e.g. HTTP or
MIME). When available, this information may be used by XML applications, but the more local
information provided by <att>xml:lang</att> should be considered to override it.
</p>
				</note>
				<p>A simple declaration for <att>xml:lang</att> might take the form</p>
				<eg>xml:lang CDATA #IMPLIED</eg>
				<p>but specific default values &may; also be given, if appropriate. In a collection
of French poems for English students, with glosses and notes in English, the <att>xml:lang</att>
attribute might be declared this way:</p>
				<eg>&lt;!ATTLIST poem   xml:lang CDATA 'fr'&gt;
&lt;!ATTLIST gloss  xml:lang CDATA 'en'&gt;
&lt;!ATTLIST note   xml:lang CDATA 'en'&gt;</eg>
			</div2>
			<div2 id="sec-normalization-checking">
				<head>Normalization Checking</head>
				<p>All XML <termref def="dt-parsedent"> parsed
entities</termref> (including <termref def="dt-docent"> document
entities</termref>) <rfc2119>SHOULD</rfc2119> be <termref def="dt-fullnorm">fully
normalized</termref> as per the definition of
<specref ref="sec-CharNorm"/> supplemented by the following definitions of
<emph id="dt-relconst">relevant constructs</emph> for XML:</p>
				<olist>
					<item>
						<p>The <termref def="dt-repltext">
replacement text</termref> of all <termref def="dt-parsedent">parsed
entities</termref>
						</p>
					</item>
					<item>
						<p>All text matching, in context, one of the following
productions:</p>
						<olist>
							<item>
								<p>
									<nt def="NT-CData">
CData</nt>
								</p>
							</item>
							<item>
								<p>
									<nt def="NT-CharData">
CharData</nt>
								</p>
							</item>
							<item>
								<p>
									<nt def="NT-content">
content</nt>
								</p>
							</item>
							<item>
								<p>
									<nt def="NT-Name"> Name</nt>
								</p>
							</item>
							<item>
								<p>
									<nt def="NT-Nmtoken">
Nmtoken</nt>
								</p>
							</item>
						</olist>
					</item>
				</olist>
				<p>However, a document is still well-formed even if it is not
<termref def="dt-fullnorm">fully normalized</termref>.
XML processors <rfc2119>SHOULD</rfc2119> provide a user option to verify that the document being
processed is in <termref def="dt-fullnorm">fully normalized</termref> form, and report to the application whether
it is or not. The option to not verify <rfc2119>SHOULD</rfc2119> be chosen only when the
input text is <termref def="dt-certified">certified</termref>,
as defined by <specref ref="sec-CharNorm"/>.</p>
				<p>The verification of full normalization <rfc2119>MUST</rfc2119> be carried out as if by
first verifying that the entity is in <termref def="dt-inclnorm">include-normalized</termref>
form as defined by <specref ref="sec-CharNorm"/> and by then verifying that none of the relevant
constructs listed above begins (after character references are
expanded) with a <termref def="dt-compchar">composing character</termref> as defined by
<specref ref="sec-CharNorm"/>.
Non-validating processors <rfc2119>MUST</rfc2119> ignore possible
denormalizations that would be caused by inclusion of external
entities that they do not read.</p>
				<note>
					<p>The <termref def="dt-compchar">composing character</termref> are all
Unicode characters of non-zero combining class, plus a small number
of class-zero characters that nevertheless take part as a
non-initial character in certain Unicode canonical
decompositions.  Since these characters are meant to follow
base characters, restricting relevant constructs (including
content) from beginning with a <termref def="dt-compchar">composing character</termref> does not
meaningfully diminish the expressiveness of XML.</p>
				</note>
				<p>If, while verifying full normalization, a processor encounters
characters for which it cannot determine the normalization
properties (i.e., characters introduced in a version of Unicode <bibref ref="Unicode"/>
later than the one used in the implementation of the processor),
then the processor &MAY;, at user option, ignore any possible
denormalizations caused by these characters. The option to ignore
those denormalizations <rfc2119>SHOULD NOT</rfc2119> be chosen by applications when
reliability or security are critical.</p>
				<p> XML processors <rfc2119>MUST NOT</rfc2119> transform the input to be in
<termref def="dt-fullnorm">fully normalized</termref> form.
XML applications that create XML 1.1 output
from either XML 1.1 or XML 1.0 input <rfc2119>SHOULD</rfc2119> ensure that the output
is <termref def="dt-fullnorm">fully normalized</termref>; it is not necessary for internal processing
forms to be <termref def="dt-fullnorm">fully normalized</termref>.</p>
				<p>The purpose of this section is to strongly encourage XML
processors to ensure that the creators of XML documents have
properly normalized them, so that XML applications can make tests
such as identity comparisons of strings without having to worry
about the different possible "spellings" of strings which
Unicode allows.
</p>
				<p>When entities are in a non-Unicode encoding, if the processor
transcodes them to Unicode, it <rfc2119>SHOULD</rfc2119> use a normalizing transcoder.
</p>
			</div2>
		</div1>
		<!-- &Elements; -->
		<div1 id="sec-logical-struct">
			<head>Logical Structures</head>
			<p>
				<termdef id="dt-element" term="Element">Each <termref def="dt-xml-doc">XML
document</termref> contains one or more <term>elements</term>, the boundaries
of which are either delimited by <termref def="dt-stag">start-tags</termref>
and <termref def="dt-etag">end-tags</termref>, or, for <termref def="dt-empty">empty</termref>
elements, by an <termref def="dt-eetag">empty-element tag</termref>. Each
element has a type, identified by name, sometimes called its <quote>generic
identifier</quote> (GI), and &may; have a set of attribute specifications.</termdef>
Each attribute specification has a <termref def="dt-attrname">name</termref>
and a <termref def="dt-attrval">value</termref>.</p>
			<scrap lang="ebnf">
				<head>Element</head>
				<prod id="NT-element" num="39">
					<lhs>element</lhs>
					<rhs>
						<nt def="NT-EmptyElemTag">EmptyElemTag</nt>
					</rhs>
					<rhs>| <nt def="NT-STag">STag</nt>
						<nt def="NT-content">content</nt>
						<nt def="NT-ETag">ETag</nt>
					</rhs>
					<wfc def="GIMatch"/>
					<vc def="elementvalid"/>
				</prod>
			</scrap>
			<p>This specification does not constrain the
			<phrase diff="add">
					<loc role="erratumref" href="E19"/>application </phrase>semantics, use, or (beyond syntax)
names of the element types and attributes, except that names beginning with
a match to <code>(('X'|'x')('M'|'m')('L'|'l'))</code> are reserved for standardization
in this or future versions of this specification.</p>
			<wfcnote id="GIMatch">
				<head>Element Type Match</head>
				<p>The <nt def="NT-Name">Name</nt>
in an element's end-tag <rfc2119>MUST</rfc2119> match the element type in the start-tag.</p>
			</wfcnote>
			<vcnote id="elementvalid">
				<head>Element Valid</head>
				<p>An element is valid
if there is a declaration matching <nt def="NT-elementdecl">elementdecl</nt>
where the <nt def="NT-Name">Name</nt> matches the element type, and one of
the following holds:</p>
				<olist>
					<item>
						<p>The declaration matches <kw>EMPTY</kw> and the element has no <termref def="dt-content">content</termref> (not even entity
references, comments, PIs or white space).</p>
					</item>
					<item>
						<p>The declaration matches <nt def="NT-children">children</nt> and the
sequence of <termref def="dt-parentchild">child elements</termref> belongs
to the language generated by the regular expression in the content model,
with optional white space, comments and
PIs (i.e. markup matching production [27] <nt def="NT-Misc">Misc</nt>) between the
start-tag and the first child element, between child elements, or between
the last child element and the end-tag. Note that a CDATA section containing
only white space or a reference
to an entity whose replacement text is character references expanding to white
space do not
match the nonterminal <nt def="NT-S">S</nt>, and
hence cannot appear in these positions; however, a
reference to an internal entity with a literal value consisting of character
references expanding to white space does match <nt def="NT-S">S</nt>, since its
replacement text is the white space resulting from expansion of the character
references.</p>
					</item>
					<item>
						<p>The declaration matches <nt def="NT-Mixed">Mixed</nt>
							<phrase diff="add">
								<loc role="erratumref" href="E11"/>,</phrase> and the content
(after replacing
any entity references with their replacement text) consists of
<termref def="dt-chardata">character data</termref>
							<phrase diff="add">
								<loc role="erratumref" href="E11"/> (including <termref def="dt-cdsection">CDATA sections</termref>)</phrase>,
<termref def="dt-comment">comments</termref>, <termref def="dt-pi">PIs</termref> and <termref def="dt-parentchild">child elements</termref> whose types match names in the
content model.</p>
					</item>
					<item>
						<p>The declaration matches <kw>ANY</kw>, and the
content (after replacing
any entity references with their replacement text)
consists of character data<phrase diff="add">
								<loc role="erratumref" href="E11"/>, <termref def="dt-cdsection">CDATA
     sections</termref>, <termref def="dt-comment">comments</termref>, <termref def="dt-pi">PIs</termref>
							</phrase> and <termref def="dt-parentchild">child elements</termref>
whose types have been declared.</p>
					</item>
				</olist>
			</vcnote>
			<div2 id="sec-starttags">
				<head>Start-Tags, End-Tags, and Empty-Element Tags</head>
				<p>
					<termdef id="dt-stag" term="Start-Tag">The beginning of every non-empty
XML element is marked by a <term>start-tag</term>.</termdef>
				</p>
				<scrap lang="ebnf">
					<head>Start-tag</head>
					<prodgroup pcw2="6" pcw4="15" pcw5="11.5">
						<prod id="NT-STag" num="40">
							<lhs>STag</lhs>
							<rhs>'&lt;' <nt def="NT-Name">Name</nt> (<nt def="NT-S">S</nt>
								<nt def="NT-Attribute">Attribute</nt>)* <nt def="NT-S">S</nt>? '&gt;'</rhs>
							<wfc def="uniqattspec"/>
						</prod>
						<prod id="NT-Attribute" num="41">
							<lhs>Attribute</lhs>
							<rhs>
								<nt def="NT-Name">Name</nt>
								<nt def="NT-Eq">Eq</nt>
								<nt def="NT-AttValue">AttValue</nt>
							</rhs>
							<vc def="ValueType"/>
							<wfc def="NoExternalRefs"/>
							<wfc def="CleanAttrVals"/>
						</prod>
					</prodgroup>
				</scrap>
				<p>The <nt def="NT-Name">Name</nt> in the start- and end-tags gives the element's <term>type</term>. <termdef id="dt-attr" term="Attribute"> The <nt def="NT-Name">Name</nt>-<nt def="NT-AttValue">AttValue</nt>
pairs are referred to as the <term>attribute specifications</term> of the
element</termdef>, <termdef id="dt-attrname" term="Attribute Name">with the <nt def="NT-Name">Name</nt> in each pair referred to as the <term>attribute name</term>
					</termdef>
and <termdef id="dt-attrval" term="Attribute Value">the content of the <nt def="NT-AttValue">AttValue</nt> (the text between the <code>'</code> or <code>"</code>
delimiters) as the <term>attribute value</term>.</termdef>  Note
that the order of attribute specifications in a start-tag or empty-element
tag is not significant.</p>
				<wfcnote id="uniqattspec">
					<head>Unique Att Spec</head>
					<p>An attribute name
<rfc2119>MUST NOT</rfc2119> appear more than once in the same start-tag or empty-element tag.</p>
				</wfcnote>
				<vcnote id="ValueType">
					<head>Attribute Value Type</head>
					<p>The attribute <rfc2119>MUST</rfc2119>
have been declared; the value <rfc2119>MUST</rfc2119> be of the type declared for it. (For attribute
types, see <specref ref="attdecls"/>.)</p>
				</vcnote>
				<wfcnote id="NoExternalRefs">
					<head>No External Entity References</head>
					<p>Attribute
values <rfc2119>MUST NOT</rfc2119> contain direct or indirect entity references to external entities.</p>
				</wfcnote>
				<wfcnote id="CleanAttrVals">
					<head>No <code>&lt;</code> in Attribute Values</head>
					<p>The <termref def="dt-repltext">replacement text</termref> of any entity
referred to directly or indirectly in an attribute value <rfc2119>MUST NOT</rfc2119> contain a <code>&lt;</code>.</p>
				</wfcnote>
				<p>An example of a start-tag:</p>
				<eg>&lt;termdef id="dt-dog" term="dog"&gt;</eg>
				<p>
					<termdef id="dt-etag" term="End Tag">The end of every element that begins
with a start-tag <rfc2119>MUST</rfc2119> be marked by an <term>end-tag</term> containing a name
that echoes the element's type as given in the start-tag:</termdef>
				</p>
				<scrap lang="ebnf">
					<head>End-tag</head>
					<prodgroup pcw2="6" pcw4="15" pcw5="11.5">
						<prod id="NT-ETag" num="42">
							<lhs>ETag</lhs>
							<rhs>'&lt;/' <nt def="NT-Name">Name</nt>
								<nt def="NT-S">S</nt>?
'&gt;'</rhs>
						</prod>
					</prodgroup>
				</scrap>
				<p>An example of an end-tag:</p>
				<eg>&lt;/termdef&gt;</eg>
				<p>
					<termdef id="dt-content" term="Content">The <termref def="dt-text">text</termref>
between the start-tag and end-tag is called the element's <term>content</term>:</termdef>
				</p>
				<scrap lang="ebnf">
					<head>Content of Elements</head>
					<prodgroup pcw2="6" pcw4="15" pcw5="11.5">
						<prod id="NT-content" num="43">
							<lhs>content</lhs>
							<rhs>
								<nt def="NT-CharData">CharData</nt>? ((<nt def="NT-element">element</nt>
| <nt def="NT-Reference">Reference</nt> | <nt def="NT-CDSect">CDSect</nt>
| <nt def="NT-PI">PI</nt> | <nt def="NT-Comment">Comment</nt>) <nt def="NT-CharData">CharData</nt>?)*</rhs>
						</prod>
					</prodgroup>
				</scrap>
				<p>
					<termdef id="dt-empty" term="Empty">An element
with no <nt def="NT-content">content</nt> is said to be <term>empty</term>.</termdef> The representation
of an empty element is either a start-tag immediately followed by an end-tag,
or an empty-element tag. <termdef id="dt-eetag" term="empty-element tag">An <term>empty-element
tag</term> takes a special form:</termdef>
				</p>
				<scrap lang="ebnf">
					<head>Tags for Empty Elements</head>
					<prodgroup pcw2="6" pcw4="15" pcw5="11.5">
						<prod id="NT-EmptyElemTag" num="44">
							<lhs>EmptyElemTag</lhs>
							<rhs>'&lt;' <nt def="NT-Name">Name</nt> (<nt def="NT-S">S</nt>
								<nt def="NT-Attribute">Attribute</nt>)* <nt def="NT-S">S</nt>? '/&gt;'</rhs>
							<wfc def="uniqattspec"/>
						</prod>
					</prodgroup>
				</scrap>
				<p>Empty-element tags &may; be used for any element which has no content, whether
or not it is declared using the keyword <kw>EMPTY</kw>. <termref def="dt-interop">For
interoperability</termref>, the empty-element tag <rfc2119>SHOULD</rfc2119>
be used, and <rfc2119>SHOULD</rfc2119> only be used, for elements which are declared
EMPTY.</p>
				<p>Examples of empty elements:</p>
				<eg>&lt;IMG align="left"
src="http://www.w3.org/Icons/WWW/w3c_home" /&gt;
&lt;br&gt;&lt;/br&gt;
&lt;br/&gt;</eg>
			</div2>
			<div2 id="elemdecls">
				<head>Element Type Declarations</head>
				<p>The <termref def="dt-element">element</termref> structure of an <termref def="dt-xml-doc">XML document</termref> &may;, for <termref def="dt-valid">validation</termref>
purposes, be constrained using element type and attribute-list declarations.
An element type declaration constrains the element's <termref def="dt-content">content</termref>.</p>
				<p>Element type declarations often constrain which element types can appear
as <termref def="dt-parentchild">children</termref> of the element. At user
option, an XML processor &MAY; issue a warning when a declaration mentions an
element type for which no declaration is provided, but this is not an error.</p>
				<p>
					<termdef id="dt-eldecl" term="Element Type declaration">An <term>element
type declaration</term> takes the form:</termdef>
				</p>
				<scrap lang="ebnf">
					<head>Element Type Declaration</head>
					<prodgroup pcw2="5.5" pcw4="18" pcw5="9">
						<prod id="NT-elementdecl" num="45">
							<lhs>elementdecl</lhs>
							<rhs>'&lt;!ELEMENT' <nt def="NT-S">S</nt>
								<nt def="NT-Name">Name</nt>
								<nt def="NT-S">S</nt>
								<nt def="NT-contentspec">contentspec</nt>
								<nt def="NT-S">S</nt>?
'&gt;'</rhs>
							<vc def="EDUnique"/>
						</prod>
						<prod id="NT-contentspec" num="46">
							<lhs>contentspec</lhs>
							<rhs>'EMPTY' | 'ANY' | <nt def="NT-Mixed">Mixed</nt>
| <nt def="NT-children">children</nt>
							</rhs>
						</prod>
					</prodgroup>
				</scrap>
				<p>where the <nt def="NT-Name">Name</nt> gives the element type being declared.</p>
				<vcnote id="EDUnique">
					<head>Unique Element Type Declaration</head>
					<p>An element type <rfc2119>MUST NOT</rfc2119> be declared more than once.</p>
				</vcnote>
				<p>Examples of element type declarations:</p>
				<eg>&lt;!ELEMENT br EMPTY&gt;
&lt;!ELEMENT p (#PCDATA|emph)* &gt;
&lt;!ELEMENT %name.para; %content.para; &gt;
&lt;!ELEMENT container ANY&gt;</eg>
				<div3 id="sec-element-content">
					<head>Element Content</head>
					<p>
						<termdef id="dt-elemcontent" term="Element content">An element <termref def="dt-stag">type</termref> has <term>element content</term> when elements
of that type <rfc2119>MUST</rfc2119> contain only <termref def="dt-parentchild">child</termref>
elements (no character data), optionally separated by white space (characters
matching the nonterminal <nt def="NT-S">S</nt>).</termdef>
						<termdef id="dt-content-model" term="Content model">In this case, the constraint includes a <term>content
model</term>, a simple grammar governing the allowed types of the
child elements and the order in which they are allowed to appear.</termdef>
The grammar is built on content particles (<nt def="NT-cp">cp</nt>s), which
consist of names, choice lists of content particles, or sequence lists of
content particles:</p>
					<scrap lang="ebnf">
						<head>Element-content Models</head>
						<prodgroup pcw2="5.5" pcw4="16" pcw5="11">
							<prod id="NT-children" num="47">
								<lhs>children</lhs>
								<rhs>(<nt def="NT-choice">choice</nt> | <nt def="NT-seq">seq</nt>)
('?' | '*' | '+')?</rhs>
							</prod>
							<prod id="NT-cp" num="48">
								<lhs>cp</lhs>
								<rhs>(<nt def="NT-Name">Name</nt> | <nt def="NT-choice">choice</nt>
| <nt def="NT-seq">seq</nt>) ('?' | '*' | '+')?</rhs>
							</prod>
							<prod id="NT-choice" num="49">
								<lhs>choice</lhs>
								<rhs>'(' <nt def="NT-S">S</nt>? <nt def="NT-cp">cp</nt> ( <nt def="NT-S">S</nt>? '|' <nt def="NT-S">S</nt>? <nt def="NT-cp">cp</nt> )+ <nt def="NT-S">S</nt>? ')'</rhs>
								<vc def="vc-PEinGroup"/>
							</prod>
							<prod id="NT-seq" num="50">
								<lhs>seq</lhs>
								<rhs>'(' <nt def="NT-S">S</nt>? <nt def="NT-cp">cp</nt> ( <nt def="NT-S">S</nt>? ',' <nt def="NT-S">S</nt>? <nt def="NT-cp">cp</nt> )* <nt def="NT-S">S</nt>? ')'</rhs>
								<vc def="vc-PEinGroup"/>
							</prod>
						</prodgroup>
					</scrap>
					<p>where each <nt def="NT-Name">Name</nt> is the type of an element which
&may; appear as a <termref def="dt-parentchild">child</termref>. Any content
particle in a choice list &may; appear in the <termref def="dt-elemcontent">element
content</termref> at the location where the choice list appears in the grammar;
content particles occurring in a sequence list <rfc2119>MUST</rfc2119> each appear in the <termref def="dt-elemcontent">element content</termref> in the order given in the list.
The optional character following a name or list governs whether the element
or the content particles in the list may occur one or more (<code>+</code>),
zero or more (<code>*</code>), or zero or one times (<code>?</code>). The
absence of such an operator means that the element or content particle <rfc2119>MUST</rfc2119>
appear exactly once. This syntax and meaning are identical to those used in
the productions in this specification.</p>
					<p>The content of an element matches a content model if and only if it is
possible to trace out a path through the content model, obeying the sequence,
choice, and repetition operators and matching each element in the content
against an element type in the content model. <termref def="dt-compat">For
compatibility</termref>, it is an error if the content model
allows an element to match more than one occurrence of an element type in the
content model. For more information, see <specref ref="determinism"/>.</p>
					<!--appendix <specref ref="determinism"/>.-->
					<!-- appendix on deterministic content models. -->
					<vcnote id="vc-PEinGroup">
						<head>Proper Group/PE Nesting</head>
						<p>Parameter-entity <termref def="dt-repltext">replacement text</termref>
							<rfc2119>MUST</rfc2119> be properly nested with parenthesized
groups. That is to say, if either of the opening or closing parentheses in
a <nt def="NT-choice">choice</nt>, <nt def="NT-seq">seq</nt>, or <nt def="NT-Mixed">Mixed</nt>
construct is contained in the replacement text for a <termref def="dt-PERef">parameter
entity</termref>, both <rfc2119>MUST</rfc2119> be contained in the same replacement text.</p>
						<p>
							<termref def="dt-interop">For interoperability</termref>, if a parameter-entity reference
appears in a <nt def="NT-choice">choice</nt>, <nt def="NT-seq">seq</nt>, or <nt def="NT-Mixed">Mixed</nt> construct, its replacement text <rfc2119>SHOULD</rfc2119> contain at
least one non-blank character, and neither the first nor last non-blank character
of the replacement text <rfc2119>SHOULD</rfc2119> be a connector (<code>|</code> or <code>,</code>).</p>
					</vcnote>
					<p>Examples of element-content models:</p>
					<eg>&lt;!ELEMENT spec (front, body, back?)&gt;
&lt;!ELEMENT div1 (head, (p | list | note)*, div2*)&gt;
&lt;!ELEMENT dictionary-body (%div.mix; | %dict.mix;)*&gt;</eg>
				</div3>
				<div3 id="sec-mixed-content">
					<head>Mixed Content</head>
					<p>
						<termdef id="dt-mixed" term="Mixed Content">An element <termref def="dt-stag">type</termref>
has <term>mixed content</term> when elements of that type &may; contain character
data, optionally interspersed with <termref def="dt-parentchild">child</termref>
elements.</termdef> In this case, the types of the child elements &may; be constrained,
but not their order or their number of occurrences:</p>
					<scrap lang="ebnf">
						<head>Mixed-content Declaration</head>
						<prodgroup pcw2="5.5" pcw4="16" pcw5="11">
							<prod id="NT-Mixed" num="51">
								<lhs>Mixed</lhs>
								<rhs>'(' <nt def="NT-S">S</nt>? '#PCDATA' (<nt def="NT-S">S</nt>?
'|' <nt def="NT-S">S</nt>? <nt def="NT-Name">Name</nt>)* <nt def="NT-S">S</nt>?
')*' </rhs>
								<rhs>| '(' <nt def="NT-S">S</nt>? '#PCDATA' <nt def="NT-S">S</nt>? ')' </rhs>
								<vc def="vc-PEinGroup"/>
								<vc def="vc-MixedChildrenUnique"/>
							</prod>
						</prodgroup>
					</scrap>
					<p>where the <nt def="NT-Name">Name</nt>s give the types of elements that
may appear as children. The
keyword <kw>#PCDATA</kw> derives historically from the term <quote>parsed
character data.</quote>
					</p>
					<vcnote id="vc-MixedChildrenUnique">
						<head>No Duplicate Types</head>
						<p>The
same name <rfc2119>MUST NOT</rfc2119> appear more than once in a single mixed-content declaration.</p>
					</vcnote>
					<p>Examples of mixed content declarations:</p>
					<eg>&lt;!ELEMENT p (#PCDATA|a|ul|b|i|em)*&gt;
&lt;!ELEMENT p (#PCDATA | %font; | %phrase; | %special; | %form;)* &gt;
&lt;!ELEMENT b (#PCDATA)&gt;</eg>
				</div3>
			</div2>
			<div2 id="attdecls">
				<head>Attribute-List Declarations</head>
				<p>
					<termref def="dt-attr">Attributes</termref> are used to associate name-value
pairs with <termref def="dt-element">elements</termref>. Attribute specifications
<rfc2119>MUST NOT</rfc2119> appear outside of <termref def="dt-stag">start-tags</termref> and <termref def="dt-eetag">empty-element tags</termref>; thus, the productions used to
recognize them appear in <specref ref="sec-starttags"/>. Attribute-list declarations
&may; be used:</p>
				<ulist>
					<item>
						<p>To define the set of attributes pertaining to a given element type.</p>
					</item>
					<item>
						<p>To establish type constraints for these attributes.</p>
					</item>
					<item>
						<p>To provide <termref def="dt-default">default values</termref> for
attributes.</p>
					</item>
				</ulist>
				<p>
					<termdef id="dt-attdecl" term="Attribute-List Declaration">
						<term>Attribute-list
declarations</term> specify the name, data type, and default value (if any)
of each attribute associated with a given element type:</termdef>
				</p>
				<scrap lang="ebnf">
					<head>Attribute-list Declaration</head>
					<prod id="NT-AttlistDecl" num="52">
						<lhs>AttlistDecl</lhs>
						<rhs>'&lt;!ATTLIST' <nt def="NT-S">S</nt>
							<nt def="NT-Name">Name</nt>
							<nt def="NT-AttDef">AttDef</nt>* <nt def="NT-S">S</nt>? '&gt;'</rhs>
					</prod>
					<prod id="NT-AttDef" num="53">
						<lhs>AttDef</lhs>
						<rhs>
							<nt def="NT-S">S</nt>
							<nt def="NT-Name">Name</nt>
							<nt def="NT-S">S</nt>
							<nt def="NT-AttType">AttType</nt>
							<nt def="NT-S">S</nt>
							<nt def="NT-DefaultDecl">DefaultDecl</nt>
						</rhs>
					</prod>
				</scrap>
				<p>The <nt def="NT-Name">Name</nt> in the <nt def="NT-AttlistDecl">AttlistDecl</nt>
rule is the type of an element. At user option, an XML processor &MAY; issue
a warning if attributes are declared for an element type not itself declared,
but this is not an error. The <nt def="NT-Name">Name</nt> in the <nt def="NT-AttDef">AttDef</nt>
rule is the name of the attribute.</p>
				<p>When more than one <nt def="NT-AttlistDecl">AttlistDecl</nt> is provided
for a given element type, the contents of all those provided are merged. When
more than one definition is provided for the same attribute of a given element
type, the first declaration is binding and later declarations are ignored. <termref def="dt-interop">For interoperability,</termref> writers of DTDs &may; choose
to provide at most one attribute-list declaration for a given element type,
at most one attribute definition for a given attribute name in an attribute-list
declaration, and at least one attribute definition in each attribute-list
declaration. For interoperability, an XML processor &MAY; at user option
issue a warning when more than one attribute-list declaration is provided
for a given element type, or more than one attribute definition is provided
for a given attribute, but this is not an error.</p>
				<div3 id="sec-attribute-types">
					<head>Attribute Types</head>
					<p>XML attribute types are of three kinds: a string type, a set of tokenized
types, and enumerated types. The string type may take any literal string as
a value; the tokenized types <phrase diff="del">
							<loc role="erratumref" href="E19"/>have varying lexical and semantic constraints</phrase>
						<phrase diff="add">
							<loc role="erratumref" href="E19"/>are more constrained</phrase>.
The validity constraints noted in the grammar are applied after the attribute
value has been normalized as described in <specref ref="AVNormalize"/>.</p>
					<scrap lang="ebnf">
						<head>Attribute Types</head>
						<prodgroup pcw4="14" pcw5="11.5">
							<prod id="NT-AttType" num="54">
								<lhs>AttType</lhs>
								<rhs>
									<nt def="NT-StringType">StringType</nt> | <nt def="NT-TokenizedType">TokenizedType</nt>
| <nt def="NT-EnumeratedType">EnumeratedType</nt>
								</rhs>
							</prod>
							<prod id="NT-StringType" num="55">
								<lhs>StringType</lhs>
								<rhs>'CDATA'</rhs>
							</prod>
							<prod id="NT-TokenizedType" num="56">
								<lhs>TokenizedType</lhs>
								<rhs>'ID'</rhs>
								<vc def="id"/>
								<vc def="one-id-per-el"/>
								<vc def="id-default"/>
								<rhs>| 'IDREF'</rhs>
								<vc def="idref"/>
								<rhs>| 'IDREFS'</rhs>
								<vc def="idref"/>
								<rhs>| 'ENTITY'</rhs>
								<vc def="entname"/>
								<rhs>| 'ENTITIES'</rhs>
								<vc def="entname"/>
								<rhs>| 'NMTOKEN'</rhs>
								<vc def="nmtok"/>
								<rhs>| 'NMTOKENS'</rhs>
								<vc def="nmtok"/>
							</prod>
						</prodgroup>
					</scrap>
					<vcnote id="id">
						<head>ID</head>
						<p>Values of type <kw>ID</kw>
							<rfc2119>MUST</rfc2119> match the <nt def="NT-Name">Name</nt> production. A name <rfc2119>MUST NOT</rfc2119> appear more than once
in an XML document as a value of this type; i.e., ID values <rfc2119>MUST</rfc2119> uniquely
identify the elements which bear them.</p>
					</vcnote>
					<vcnote id="one-id-per-el">
						<head>One ID per Element Type</head>
						<p>An element type <rfc2119>MUST NOT</rfc2119> have more than one ID attribute specified.</p>
					</vcnote>
					<vcnote id="id-default">
						<head>ID Attribute Default</head>
						<p>An ID attribute
<rfc2119>MUST</rfc2119> have a declared default of <kw>#IMPLIED</kw> or <kw>#REQUIRED</kw>.</p>
					</vcnote>
					<vcnote id="idref">
						<head>IDREF</head>
						<p>Values of type <kw>IDREF</kw>
							<rfc2119>MUST</rfc2119>
match the <nt def="NT-Name">Name</nt> production, and values of type <kw>IDREFS</kw>
							<rfc2119>MUST</rfc2119> match <nt def="NT-Names">Names</nt>; each <nt def="NT-Name">Name</nt>
							<rfc2119>MUST</rfc2119> match the value of an ID attribute on some element in the XML document;
i.e. <kw>IDREF</kw> values <rfc2119>MUST</rfc2119> match the value of some ID attribute.</p>
					</vcnote>
					<vcnote id="entname">
						<head>Entity Name</head>
						<p>Values of type <kw>ENTITY</kw>
							<rfc2119>MUST</rfc2119> match the <nt def="NT-Name">Name</nt> production, values of type <kw>ENTITIES</kw>
							<rfc2119>MUST</rfc2119> match <nt def="NT-Names">Names</nt>; each <nt def="NT-Name">Name</nt>
							<rfc2119>MUST</rfc2119> match the name of an <termref def="dt-unparsed">unparsed entity</termref>
declared in the <termref def="dt-doctype">DTD</termref>.</p>
					</vcnote>
					<vcnote id="nmtok">
						<head>Name Token</head>
						<p>Values of type <kw>NMTOKEN</kw>
							<rfc2119>MUST</rfc2119> match the <nt def="NT-Nmtoken">Nmtoken</nt> production; values of type <kw>NMTOKENS</kw>
							<rfc2119>MUST</rfc2119> match <nt def="NT-Nmtokens">Nmtokens</nt>.</p>
					</vcnote>
					<!-- why?
<p>The XML processor must normalize attribute values before
passing them to the application, as described in
<specref ref="AVNormalize"/>.</p>-->
					<p>
						<termdef id="dt-enumerated" term="Enumerated Attribute
Values">
							<term>Enumerated attributes</term>
							<phrase diff="del"><!--loc role="erratumref" href="PE148"/-->
								<rfc2119>MUST</rfc2119> take one of a list of values
provided in the declaration</phrase>
							<phrase diff="add"><!--loc role="erratumref" href="PE148"/-->have a list of allowed
values in their declaration</phrase>
						</termdef>. <phrase diff="add"><!--loc role="erratumref" href="PE148"/-->They <rfc2119>MUST</rfc2119> take one of those values.  </phrase>There are two kinds of enumerated<phrase diff="add"><!--loc role="erratumref" href="PE148"/--> attribute</phrase> types:</p>
					<scrap lang="ebnf">
						<head>Enumerated Attribute Types</head>
						<prod id="NT-EnumeratedType" num="57">
							<lhs>EnumeratedType</lhs>
							<rhs>
								<nt def="NT-NotationType">NotationType</nt>
| <nt def="NT-Enumeration">Enumeration</nt>
							</rhs>
						</prod>
						<prod id="NT-NotationType" num="58">
							<lhs>NotationType</lhs>
							<rhs>'NOTATION' <nt def="NT-S">S</nt> '(' <nt def="NT-S">S</nt>? <nt def="NT-Name">Name</nt> (<nt def="NT-S">S</nt>? '|' <nt def="NT-S">S</nt>? <nt def="NT-Name">Name</nt>)* <nt def="NT-S">S</nt>? ')' </rhs>
							<vc def="notatn"/>
							<vc def="OneNotationPer"/>
							<vc def="NoNotationEmpty"/>
							<vc def="NoDuplicateTokens"/>
						</prod>
						<prod id="NT-Enumeration" num="59">
							<lhs>Enumeration</lhs>
							<rhs>'(' <nt def="NT-S">S</nt>? <nt def="NT-Nmtoken">Nmtoken</nt>
(<nt def="NT-S">S</nt>? '|' <nt def="NT-S">S</nt>? <nt def="NT-Nmtoken">Nmtoken</nt>)* <nt def="NT-S">S</nt>? ')'</rhs>
							<vc def="enum"/>
							<vc def="NoDuplicateTokens"/>
						</prod>
					</scrap>
					<p>A <kw>NOTATION</kw> attribute identifies a <termref def="dt-notation">notation</termref>,
declared in the DTD with associated system and/or public identifiers, to be
used in interpreting the element to which the attribute is attached.</p>
					<vcnote id="notatn">
						<head>Notation Attributes</head>
						<p>Values of this type
<rfc2119>MUST</rfc2119> match one of the <titleref href="#Notations">notation</titleref> names
included in the declaration; all notation names in the declaration <rfc2119>MUST</rfc2119> be
declared.</p>
					</vcnote>
					<vcnote id="OneNotationPer">
						<head>One Notation Per Element Type</head>
						<p>An element type <rfc2119>MUST NOT</rfc2119> have more than one <kw>NOTATION</kw>
attribute specified.</p>
					</vcnote>
					<vcnote id="NoNotationEmpty">
						<head>No Notation on Empty Element</head>
						<p>
							<termref def="dt-compat">For compatibility</termref>,
an attribute of type <kw>NOTATION</kw>
							<rfc2119>MUST NOT</rfc2119> be declared on an element
declared <kw>EMPTY</kw>.</p>
					</vcnote>
					<vcnote id="NoDuplicateTokens">
						<head>No Duplicate
Tokens</head>
						<p>The notation names in a single <nt def="NT-NotationType">NotationType</nt>
attribute declaration, as well as the <nt def="NT-Nmtoken">NmToken</nt>s in a single
<nt def="NT-Enumeration">Enumeration</nt> attribute declaration, <rfc2119>MUST</rfc2119> all be distinct.</p>
					</vcnote>
					<vcnote id="enum">
						<head>Enumeration</head>
						<p>Values of this type <rfc2119>MUST</rfc2119> match
one of the <nt def="NT-Nmtoken">Nmtoken</nt> tokens in the declaration.</p>
					</vcnote>
					<p>
						<termref def="dt-interop">For interoperability,</termref> the same <nt def="NT-Nmtoken">Nmtoken</nt>
						<rfc2119>SHOULD NOT</rfc2119> occur more than once in the enumerated
attribute types of a single element type.</p>
				</div3>
				<div3 id="sec-attr-defaults">
					<head>Attribute Defaults</head>
					<p>An <termref def="dt-attdecl">attribute declaration</termref> provides information
on whether the attribute's presence is <rfc2119>REQUIRED</rfc2119>, and if not, how an XML processor
is to react if a declared attribute is absent in a document.</p>
					<scrap lang="ebnf">
						<head>Attribute Defaults</head>
						<prodgroup pcw4="14" pcw5="11.5">
							<prod id="NT-DefaultDecl" num="60">
								<lhs>DefaultDecl</lhs>
								<rhs>'#REQUIRED' |&nbsp;'#IMPLIED' </rhs>
								<rhs>| (('#FIXED' <nt def="NT-S">S</nt>)? <nt def="NT-AttValue">AttValue</nt>)</rhs>
								<vc def="RequiredAttr"/>
								<vc def="defattrvalid"/>
								<wfc def="CleanAttrVals"/>
								<vc def="FixedAttr"/>
								<wfc def="NoExternalRefs" diff="add"/>
								<com diff="add"><loc role="erratumref" href="E20"/></com>
							</prod>
						</prodgroup>
					</scrap>
					<p>In an attribute declaration, <kw>#REQUIRED</kw> means that the attribute
<rfc2119>MUST</rfc2119> always be provided, <kw>#IMPLIED</kw> that no default value is provided.
<!-- not any more!!
<kw>#IMPLIED</kw> means that if the attribute is omitted
from an element of this type,
the XML processor must inform the application
that no value was specified; no constraint is placed on the behavior
of the application. -->
						<termdef id="dt-default" term="Attribute Default">If
the declaration is neither <kw>#REQUIRED</kw> nor <kw>#IMPLIED</kw>, then
the <nt def="NT-AttValue">AttValue</nt> value contains the declared <term>default</term>
value; the <kw>#FIXED</kw> keyword states that the attribute <rfc2119>MUST</rfc2119> always have
the default value.
When an XML processor encounters
an element
without a specification for an attribute for which it has read a default
value declaration, it <rfc2119>MUST</rfc2119> report the attribute with the declared default
value to the application.</termdef>
					</p>
					<vcnote id="RequiredAttr">
						<head>Required Attribute</head>
						<p>If the default
declaration is the keyword <kw>#REQUIRED</kw>, then the attribute <rfc2119>MUST</rfc2119> be
specified for all elements of the type in the attribute-list declaration.</p>
					</vcnote>
					<vcnote id="defattrvalid">
						<head>Attribute Default Value Syntactically Correct</head>
						<p>The declared default value <rfc2119>MUST</rfc2119> meet the syntactic
constraints of the declared attribute type.<phrase diff="add">
								<loc role="erratumref" href="E12"/> That is, the default value of an attribute:</phrase>
						</p>
						<ulist>
							<item>
								<p diff="add">
									<loc role="erratumref" href="E12"/>of type IDREF or ENTITY must match the <nt def="NT-Name">Name</nt> production;</p>
							</item>
							<item>
								<p diff="add">
									<loc role="erratumref" href="E12"/>of type IDREFS or ENTITIES must match the <nt def="NT-Names">Names</nt> production;</p>
							</item>
							<item>
								<p diff="add">
									<loc role="erratumref" href="E12"/>of type NMTOKEN must match the <nt def="NT-Nmtoken">Nmtoken</nt> production;</p>
							</item>
							<item>
								<p diff="add">
									<loc role="erratumref" href="E12"/>of type NMTOKENS must match the <nt def="NT-Nmtokens">Nmtokens</nt> production;</p>
							</item>
							<item>
								<p diff="add">
									<loc role="erratumref" href="E12"/>of an <nt def="NT-EnumeratedType">enumerated type</nt> (either a <nt def="NT-NotationType">NOTATION</nt> type or an <nt def="NT-Enumeration">enumeration</nt>) must match one of the enumerated values.</p>
							</item>
						</ulist>
						<p>Note that only the
syntactic constraints of the type are required here; other constraints (e.g.
that the value be the name of a declared unparsed entity, for an attribute of
type ENTITY) <phrase diff="del">
								<loc role="erratumref" href="E12"/>may come into play if the declared default value is actually used
(an element without a specification for this attribute occurs)</phrase>
							<phrase diff="add">
								<loc role="erratumref" href="E12"/>will be reported by a validating
parser only if an element without a specification for this attribute
actually occurs</phrase>.</p>
					</vcnote>
					<vcnote id="FixedAttr">
						<head>Fixed Attribute Default</head>
						<p>If an attribute
has a default value declared with the <kw>#FIXED</kw> keyword, instances of
that attribute <rfc2119>MUST</rfc2119> match the default value.</p>
					</vcnote>
					<p>Examples of attribute-list declarations:</p>
					<eg>&lt;!ATTLIST termdef
id      ID      #REQUIRED
name    CDATA   #IMPLIED&gt;
&lt;!ATTLIST list
type    (bullets|ordered|glossary)  "ordered"&gt;
&lt;!ATTLIST form
method  CDATA   #FIXED "POST"&gt;</eg>
				</div3>
				<div3 id="AVNormalize">
					<head>Attribute-Value Normalization</head>
					<p>Before the value of an attribute is passed to the application or checked
for validity, the XML processor <rfc2119>MUST</rfc2119> normalize the attribute value by applying
the algorithm below, or by using some other method such that the value passed
to the application is the same as that produced by the algorithm.</p>
					<olist>
						<item>
							<p>All line breaks <rfc2119>MUST</rfc2119> have been normalized on input to #xA as described
in <specref ref="sec-line-ends"/>, so the rest of this algorithm operates
on text normalized in this way.</p>
						</item>
						<item>
							<p>Begin with a normalized value consisting of the empty string.</p>
						</item>
						<item>
							<p>For each character, entity reference, or character reference in the
unnormalized attribute value, beginning with the first and continuing to the
last, do the following:</p>
							<ulist>
								<item>
									<p>For a character reference, append the referenced character to the
normalized value.</p>
								</item>
								<item>
									<p>For an entity reference, recursively apply step 3 of this algorithm
to the replacement text of the entity.</p>
								</item>
								<item>
									<p>For a white space character (#x20, #xD, #xA, #x9), append a space
character (#x20) to the normalized value.</p>
								</item>
								<item>
									<p>For another character, append the character to the normalized value.</p>
								</item>
							</ulist>
						</item>
					</olist>
					<p>If the attribute type is not CDATA, then the XML processor <rfc2119>MUST</rfc2119> further
process the normalized attribute value by discarding any leading and trailing
space (#x20) characters, and by replacing sequences of space (#x20) characters
by a single space (#x20) character.</p>
					<p>Note that if the unnormalized attribute value contains a character reference
to a white space character other than space (#x20), the normalized value contains
the referenced character itself (#xD, #xA or #x9). This contrasts with the
case where the unnormalized value contains a white space character (not a
reference), which is replaced with a space character (#x20) in the normalized
value and also contrasts with the case where the unnormalized value contains
an entity reference whose replacement text contains a white space character;
being recursively processed, the white space character is replaced with a
space character (#x20) in the normalized value.</p>
					<p>All attributes for which no declaration has been read <rfc2119>SHOULD</rfc2119> be treated
by a non-validating processor as if declared <kw>CDATA</kw>.</p>
					<p>It
is an error if an
<termref def="dt-attrval">attribute
value</termref> contains a <termref def="dt-entref">reference</termref> to an
entity for which no declaration has been read.</p>
					<p>Following are examples of attribute normalization. Given the following
declarations:</p>
					<eg>&lt;!ENTITY d "&amp;#xD;"&gt;
&lt;!ENTITY a "&amp;#xA;"&gt;
&lt;!ENTITY da "&amp;#xD;&amp;#xA;"&gt;</eg>
					<p>the attribute specifications in the left column below would be normalized
to the character sequences of the middle column if the attribute <att>a</att>
is declared <kw>NMTOKENS</kw> and to those of the right columns if <att>a</att>
is declared <kw>CDATA</kw>.</p>
					<table border="1" frame="border" summary="Attribute normalization summary">
						<thead>
							<tr>
								<th>Attribute specification</th>
								<th>a is NMTOKENS</th>
								<th>a is CDATA</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<eg>a="
xyz"</eg>
								</td>
								<td>
									<eg>x y z</eg>
								</td>
								<td>
									<eg>#x20 #x20 x y z</eg>
								</td>
							</tr>
							<tr>
								<td>
									<eg>a="&amp;d;&amp;d;A&amp;a;&amp;#x20;&amp;a;B&amp;da;"</eg>
								</td>
								<td>
									<eg>A #x20 B</eg>
								</td>
								<td>
									<eg>#x20 #x20 A #x20 #x20 #x20 B #x20 #x20</eg>
								</td>
							</tr>
							<tr>
								<td>
									<eg>a=
"&amp;#xd;&amp;#xd;A&amp;#xa;&amp;#xa;B&amp;#xd;&amp;#xa;"</eg>
								</td>
								<td>
									<eg>#xD #xD A #xA #xA B #xD #xA</eg>
								</td>
								<td>
									<eg>#xD #xD A #xA #xA B #xD #xA</eg>
								</td>
							</tr>
						</tbody>
					</table>
					<p>Note that the last example is invalid (but well-formed) if <att>a</att>
is declared to be of type <kw>NMTOKENS</kw>.</p>
				</div3>
			</div2>
			<div2 id="sec-condition-sect">
				<head>Conditional Sections</head>
				<p>
					<termdef id="dt-cond-section" term="conditional section">
						<term>Conditional
sections</term> are portions of the <termref def="dt-doctype">document type
declaration external subset</termref> or
of external parameter entities which are included in, or excluded from,
the logical structure of the DTD based on the keyword which governs them.</termdef>
				</p>
				<scrap lang="ebnf">
					<head>Conditional Section</head>
					<prodgroup pcw2="9" pcw4="14.5">
						<prod id="NT-conditionalSect" num="61">
							<lhs>conditionalSect</lhs>
							<rhs>
								<nt def="NT-includeSect">includeSect</nt> | <nt def="NT-ignoreSect">ignoreSect</nt>
							</rhs>
						</prod>
						<prod id="NT-includeSect" num="62">
							<lhs>includeSect</lhs>
							<rhs>'&lt;![' <nt def="NT-S">S</nt>? 'INCLUDE' <nt def="NT-S">S</nt>? '[' <nt def="NT-extSubsetDecl">extSubsetDecl</nt>
']]&gt;' </rhs>
							<vc def="condsec-nesting"/>
						</prod>
						<prod id="NT-ignoreSect" num="63">
							<lhs>ignoreSect</lhs>
							<rhs>'&lt;![' <nt def="NT-S">S</nt>? 'IGNORE' <nt def="NT-S">S</nt>? '[' <nt def="NT-ignoreSectContents">ignoreSectContents</nt>*
']]&gt;'</rhs>
							<vc def="condsec-nesting"/>
						</prod>
						<prod id="NT-ignoreSectContents" num="64">
							<lhs>ignoreSectContents</lhs>
							<rhs>
								<nt def="NT-Ignore">Ignore</nt> ('&lt;![' <nt def="NT-ignoreSectContents">ignoreSectContents</nt> ']]&gt;' <nt def="NT-Ignore">Ignore</nt>)*</rhs>
						</prod>
						<prod id="NT-Ignore" num="65">
							<lhs>Ignore</lhs>
							<rhs>
								<nt def="NT-Char">Char</nt>* - (<nt def="NT-Char">Char</nt>*
('&lt;![' | ']]&gt;') <nt def="NT-Char">Char</nt>*) </rhs>
						</prod>
					</prodgroup>
				</scrap>
				<vcnote id="condsec-nesting">
					<head>Proper Conditional Section/PE Nesting</head>
					<p>If any of the "<code>&lt;![</code>",
"<code>[</code>", or "<code>]]&gt;</code>" of a conditional section is contained
in the replacement text for a parameter-entity reference, all of them <rfc2119>MUST</rfc2119>
be contained in the same replacement text.</p>
				</vcnote>
				<p>Like the internal and external DTD subsets, a conditional section may contain
one or more complete declarations, comments, processing instructions, or nested
conditional sections, intermingled with white space.</p>
				<p>If the keyword of the conditional section is <kw>INCLUDE</kw>, then the
contents of the conditional section <rfc2119>MUST</rfc2119> be <phrase diff="del"><!--loc role="erratumref" href="PE148"/-->considered</phrase>
					<phrase diff="add"><!--loc role="erratumref" href="PE148"/-->processed as</phrase>
part of the DTD. If the keyword of
the conditional section is <kw>IGNORE</kw>, then the contents of the conditional
section <rfc2119>MUST</rfc2119>
					<phrase diff="del"><!--loc role="erratumref" href="PE148"/-->be
considered as not logically</phrase>
					<phrase diff="add"><!--loc role="erratumref" href="PE148"/-->
						<rfc2119>NOT</rfc2119> be processed as</phrase> part of the DTD.
If a conditional section with a keyword of <kw>INCLUDE</kw> occurs within
a larger conditional section with a keyword of <kw>IGNORE</kw>, both the outer
and the inner conditional sections <rfc2119>MUST</rfc2119> be ignored. The contents
of an ignored conditional section <rfc2119>MUST</rfc2119> be parsed by ignoring all characters after
the "<code>[</code>" following the keyword, except conditional section starts
"<code>&lt;![</code>" and ends "<code>]]&gt;</code>", until the matching conditional
section end is found. Parameter entity references <rfc2119>MUST NOT</rfc2119> be recognized in this
process.</p>
				<p>If the keyword of the conditional section is a parameter-entity reference,
the parameter entity <rfc2119>MUST</rfc2119> be replaced by its content before the processor
decides whether to include or ignore the conditional section.</p>
				<p>An example:</p>
				<eg>&lt;!ENTITY % draft 'INCLUDE' &gt;
&lt;!ENTITY % final 'IGNORE' &gt;
&lt;![%draft;[
&lt;!ELEMENT book (comments*, title, body, supplements?)&gt;
]]&gt;
&lt;![%final;[
&lt;!ELEMENT book (title, body, supplements?)&gt;
]]&gt;</eg>
			</div2>
			<!--
<div2 id='sec-pass-to-app'>
<head>XML Processor Treatment of Logical Structure</head>
<p>When an XML processor encounters a start-tag, it must make
at least the following information available to the application:
<ulist>
<item>
<p>the element type's generic identifier</p>
</item>
<item>
<p>the names of attributes known to apply to this element type
(validating processors must make available names of all attributes
declared for the element type; non-validating processors must
make available at least the names of the attributes for which
values are specified.
</p>
</item>
</ulist>
</p>
</div2>
-->
		</div1>
		<!-- &Entities; -->
		<div1 id="sec-physical-struct">
			<head>Physical Structures</head>
			<p>
				<termdef id="dt-entity" term="Entity">An XML document may consist of one
or many storage units. These
are called <term>entities</term>; they all have <term>content</term> and are
all (except for the <termref def="dt-docent">document entity</termref> and
the <termref def="dt-doctype">external DTD subset</termref>) identified by
entity <term>name</term>.</termdef> Each XML document has one entity
called the <termref def="dt-docent">document entity</termref>, which serves
as the starting point for the <termref def="dt-xml-proc">XML processor</termref>
and may contain the whole document.</p>
			<p>Entities may be either parsed or unparsed. <termdef id="dt-parsedent" term="Text Entity">The contents of a <term>parsed
entity</term> are referred to as its <termref def="dt-repltext">replacement
text</termref>; this <termref def="dt-text">text</termref> is considered an
integral part of the document.</termdef>
			</p>
			<p>
				<termdef id="dt-unparsed" term="Unparsed Entity">An <term>unparsed entity</term>
is a resource whose contents may or may not be <termref def="dt-text">text</termref>,
and if text, may
be other than XML. Each unparsed entity has an associated <termref def="dt-notation">notation</termref>, identified by name. Beyond a requirement
that an XML processor make the identifiers for the entity and notation available
to the application, XML places no constraints on the contents of unparsed
entities.</termdef>
			</p>
			<p>Parsed entities are invoked by name using entity references; unparsed entities
by name, given in the value of <kw>ENTITY</kw> or <kw>ENTITIES</kw> attributes.</p>
			<p>
				<termdef id="gen-entity" term="general entity">
					<term>General entities</term>
are entities for use within the document content. In this specification, general
entities are sometimes referred to with the unqualified term <emph>entity</emph>
when this leads to no ambiguity.</termdef>
				<termdef id="dt-PE" term="Parameter entity">
					<term>Parameter
entities</term> are parsed entities for use within the DTD.</termdef>
These two types of entities use different forms of reference and are recognized
in different contexts. Furthermore, they occupy different namespaces; a parameter
entity and a general entity with the same name are two distinct entities.</p>
			<div2 id="sec-references">
				<head>Character and Entity References</head>
				<p>
					<termdef id="dt-charref" term="Character Reference"> A <term>character
reference</term> refers to a specific character in the ISO/IEC 10646 character
set, for example one not directly accessible from available input devices.</termdef>
				</p>
				<scrap lang="ebnf">
					<head>Character Reference</head>
					<prod id="NT-CharRef" num="66">
						<lhs>CharRef</lhs>
						<rhs>'&amp;#' [0-9]+ ';' </rhs>
						<rhs>| '&amp;#x' [0-9a-fA-F]+ ';'</rhs>
						<wfc def="wf-Legalchar"/>
					</prod>
				</scrap>
				<wfcnote id="wf-Legalchar">
					<head>Legal Character</head>
					<p>Characters referred
to using character references <rfc2119>MUST</rfc2119> match the production for <nt def="NT-Char">Char</nt>.</p>
				</wfcnote>
				<p>If the character reference begins with <quote><code>&amp;#x</code></quote>,
the digits and letters up to the terminating <code>;</code> provide a hexadecimal
representation of the character's code point in ISO/IEC 10646. If it begins
just with <quote><code>&amp;#</code></quote>, the digits up to the terminating <code>;</code>
provide a decimal representation of the character's code point.</p>
				<p>
					<termdef id="dt-entref" term="Entity Reference">An <term>entity reference</term>
refers to the content of a named entity.</termdef>
					<termdef id="dt-GERef" term="General Entity Reference">References to parsed general entities use
ampersand (<code>&amp;</code>) and semicolon (<code>;</code>) as delimiters.</termdef>
					<termdef id="dt-PERef" term="Parameter-entity reference">
						<term>Parameter-entity references</term>
use percent-sign (<code>%</code>) and semicolon (<code>;</code>) as delimiters.</termdef>
				</p>
				<scrap lang="ebnf">
					<head>Entity Reference</head>
					<prod id="NT-Reference" num="67">
						<lhs>Reference</lhs>
						<rhs>
							<nt def="NT-EntityRef">EntityRef</nt> | <nt def="NT-CharRef">CharRef</nt>
						</rhs>
					</prod>
					<prod id="NT-EntityRef" num="68">
						<lhs>EntityRef</lhs>
						<rhs>'&amp;' <nt def="NT-Name">Name</nt> ';'</rhs>
						<wfc def="wf-entdeclared"/>
						<vc def="vc-entdeclared"/>
						<wfc def="textent"/>
						<wfc def="norecursion"/>
					</prod>
					<prod id="NT-PEReference" num="69">
						<lhs>PEReference</lhs>
						<rhs>'%' <nt def="NT-Name">Name</nt> ';'</rhs>
						<vc def="vc-entdeclared"/>
						<wfc def="norecursion"/>
						<wfc def="indtd"/>
					</prod>
				</scrap>
				<wfcnote id="wf-entdeclared">
					<head>Entity Declared</head>
					<p>In a document
without any DTD, a document with only an internal DTD subset which contains
no parameter entity references, or a document with <quote><code>standalone='yes'</code></quote>, for
an entity reference that does not occur within the external subset or a parameter
entity, the <nt def="NT-Name">Name</nt> given in the entity reference <rfc2119>MUST</rfc2119>
						<termref def="dt-match">match</termref> that in an <titleref href="#sec-entity-decl">entity
declaration</titleref> that does not occur within the external subset or a
parameter entity, except that well-formed documents need not declare
any of the following entities: &magicents;. The
declaration of a general entity <rfc2119>MUST</rfc2119> precede any reference to it which appears
in a default value in an attribute-list declaration.</p>
					<p>Note
that non-validating processors are <titleref href="#include-if-valid">not
obligated to</titleref> to read and process entity declarations occurring in parameter entities or in
the external subset; for such documents,
the rule that an entity must be declared is a well-formedness constraint only
if <titleref href="#sec-rmd">standalone='yes'</titleref>.</p>
				</wfcnote>
				<vcnote id="vc-entdeclared">
					<head>Entity Declared</head>
					<p>In a document with an external subset or <phrase diff="del">
							<loc role="erratumref" href="E21"/>external</phrase> parameter <phrase diff="del">
							<loc role="erratumref" href="E17"/>entities</phrase>
						<phrase diff="add">
							<loc role="erratumref" href="E17"/>entity references</phrase> with 
					<quote><code>standalone='no'</code></quote>,
the <nt def="NT-Name">Name</nt> given in the entity reference <rfc2119>MUST</rfc2119>
						<termref def="dt-match">match</termref> that in an <titleref href="#sec-entity-decl">entity
declaration</titleref>. For interoperability, valid documents <rfc2119>SHOULD</rfc2119> declare
the entities &magicents;, in the form specified in <specref ref="sec-predefined-ent"/>.
The declaration of a parameter entity <rfc2119>MUST</rfc2119> precede any reference to it. Similarly,
the declaration of a general entity <rfc2119>MUST</rfc2119> precede any attribute-list
declaration containing a default value with a direct or indirect reference
to that general entity.</p>
				</vcnote>
				<!-- FINAL EDIT: is this duplication too clumsy? -->
				<wfcnote id="textent">
					<head>Parsed Entity</head>
					<p>An entity reference <rfc2119>MUST
NOT</rfc2119> contain the name of an <termref def="dt-unparsed">unparsed entity</termref>.
Unparsed entities may be referred to only in <termref def="dt-attrval">attribute
values</termref> declared to be of type <kw>ENTITY</kw> or <kw>ENTITIES</kw>.</p>
				</wfcnote>
				<wfcnote id="norecursion">
					<head>No Recursion</head>
					<p>A parsed entity <rfc2119>MUST NOT</rfc2119> contain a recursive reference to itself, either directly or indirectly.</p>
				</wfcnote>
				<wfcnote id="indtd">
					<head>In DTD</head>
					<p>Parameter-entity references <rfc2119>MUST NOT</rfc2119> appear outside
the <termref def="dt-doctype">DTD</termref>.</p>
				</wfcnote>
				<p>Examples of character and entity references:</p>
				<eg>Type &lt;key&gt;less-than&lt;/key&gt; (&amp;#x3C;) to save options.
This document was prepared on &amp;docdate; and
is classified &amp;security-level;.</eg>
				<p>Example of a parameter-entity reference:</p>
				<eg><![CDATA[<!-- declare the parameter entity "ISOLat2"... -->
<!ENTITY % ISOLat2
SYSTEM "http://www.xml.com/iso/isolat2-xml.entities" >
<!-- ... now reference it. -->
%ISOLat2;]]></eg>
			</div2>
			<div2 id="sec-entity-decl">
				<head>Entity Declarations</head>
				<p>
					<termdef id="dt-entdecl" term="entity declaration"> Entities are declared
thus:</termdef>
				</p>
				<scrap lang="ebnf">
					<head>Entity Declaration</head>
					<prodgroup pcw2="5" pcw4="18.5">
						<prod id="NT-EntityDecl" num="70">
							<lhs>EntityDecl</lhs>
							<rhs>
								<nt def="NT-GEDecl">GEDecl</nt>
								<!--</rhs><com>General entities</com>
<rhs>--> | <nt def="NT-PEDecl">PEDecl</nt>
							</rhs>
							<!--<com>Parameter entities</com>-->
						</prod>
						<prod id="NT-GEDecl" num="71">
							<lhs>GEDecl</lhs>
							<rhs>'&lt;!ENTITY' <nt def="NT-S">S</nt>
								<nt def="NT-Name">Name</nt>
								<nt def="NT-S">S</nt>
								<nt def="NT-EntityDef">EntityDef</nt>
								<nt def="NT-S">S</nt>?
'&gt;'</rhs>
						</prod>
						<prod id="NT-PEDecl" num="72">
							<lhs>PEDecl</lhs>
							<rhs>'&lt;!ENTITY' <nt def="NT-S">S</nt> '%' <nt def="NT-S">S</nt>
								<nt def="NT-Name">Name</nt>
								<nt def="NT-S">S</nt>
								<nt def="NT-PEDef">PEDef</nt>
								<nt def="NT-S">S</nt>? '&gt;'</rhs>
							<!--<com>Parameter entities</com>-->
						</prod>
						<prod id="NT-EntityDef" num="73">
							<lhs>EntityDef</lhs>
							<rhs>
								<nt def="NT-EntityValue">EntityValue</nt>
								<!--</rhs>
<rhs>-->| (<nt def="NT-ExternalID">ExternalID</nt>
								<nt def="NT-NDataDecl">NDataDecl</nt>?)</rhs>
							<!-- <nt def='NT-ExternalDef'>ExternalDef</nt></rhs> -->
						</prod>
						<!-- FINAL EDIT: what happened to WFs here? -->
						<prod id="NT-PEDef" num="74">
							<lhs>PEDef</lhs>
							<rhs>
								<nt def="NT-EntityValue">EntityValue</nt> | <nt def="NT-ExternalID">ExternalID</nt>
							</rhs>
						</prod>
					</prodgroup>
				</scrap>
				<p>The <nt def="NT-Name">Name</nt> identifies the entity in an <termref def="dt-entref">entity
reference</termref> or, in the case of an unparsed entity, in the value of
an <kw>ENTITY</kw> or <kw>ENTITIES</kw> attribute. If the same entity is declared
more than once, the first declaration encountered is binding; at user option,
an XML processor &MAY; issue a warning if entities are declared multiple times.</p>
				<div3 id="sec-internal-ent">
					<head>Internal Entities</head>
					<p>
						<termdef id="dt-internent" term="Internal Entity Replacement Text">If the
entity definition is an <nt def="NT-EntityValue">EntityValue</nt>, the defined
entity is called an <term>internal entity</term>. There is no separate physical
storage object, and the content of the entity is given in the declaration.</termdef>
Note that some processing of entity and character references in the <termref def="dt-litentval">literal entity value</termref> may be required to produce
the correct <termref def="dt-repltext">replacement text</termref>: see <specref ref="intern-replacement"/>.</p>
					<p>An internal entity is a <termref def="dt-parsedent">parsed entity</termref>.</p>
					<p>Example of an internal entity declaration:</p>
					<eg>&lt;!ENTITY Pub-Status "This is a pre-release of the
specification."&gt;</eg>
				</div3>
				<div3 id="sec-external-ent">
					<head>External Entities</head>
					<p>
						<termdef id="dt-extent" term="External Entity">If the entity is not internal,
it is an <term>external entity</term>, declared as follows:</termdef>
					</p>
					<scrap lang="ebnf">
						<head>External Entity Declaration</head>
						<!--
<prod id='NT-ExternalDef'><lhs>ExternalDef</lhs>
<rhs></prod> -->
						<prod id="NT-ExternalID" num="75">
							<lhs>ExternalID</lhs>
							<rhs>'SYSTEM' <nt def="NT-S">S</nt>
								<nt def="NT-SystemLiteral">SystemLiteral</nt>
							</rhs>
							<rhs>| 'PUBLIC' <nt def="NT-S">S</nt>
								<nt def="NT-PubidLiteral">PubidLiteral</nt>
								<nt def="NT-S">S</nt>
								<nt def="NT-SystemLiteral">SystemLiteral</nt>
							</rhs>
						</prod>
						<prod id="NT-NDataDecl" num="76">
							<lhs>NDataDecl</lhs>
							<rhs>
								<nt def="NT-S">S</nt> 'NDATA' <nt def="NT-S">S</nt>
								<nt def="NT-Name">Name</nt>
							</rhs>
							<vc def="not-declared"/>
						</prod>
					</scrap>
					<p>If the <nt def="NT-NDataDecl">NDataDecl</nt> is present, this is a general <termref def="dt-unparsed">unparsed entity</termref>; otherwise it is a parsed entity.</p>
					<vcnote id="not-declared">
						<head>Notation Declared</head>
						<p>The <nt def="NT-Name">Name</nt>
							<rfc2119>MUST</rfc2119> match the declared name of a <termref def="dt-notation">notation</termref>.</p>
					</vcnote>
					<p>
						<termdef id="dt-sysid" term="System Identifier">The <nt def="NT-SystemLiteral">SystemLiteral</nt> is called the entity's <term>system
identifier</term>. It is meant to be
converted to a URI reference
(as defined in <bibref ref="rfc3986" diff="chg"/><phrase diff="del"><loc role="erratumref" href="E22"/>, updated by <bibref ref="rfc2732"/></phrase>),
as part of the
process of dereferencing it to obtain input for the XML processor to construct the
entity's replacement text.</termdef> It is an error for a fragment identifier
(beginning with a <code>#</code> character) to be part of a system identifier.
Unless otherwise provided by information outside the scope of this specification
(e.g. a special XML element type defined by a particular DTD, or a processing
instruction defined by a particular application specification), relative URIs
are relative to the location of the resource within which the entity declaration
occurs. This is defined to
be the external entity containing the '&lt;' which starts the declaration, at the
point when it is parsed as a declaration.
A URI might thus be relative to the <termref def="dt-docent">document
entity</termref>, to the entity containing the <termref def="dt-doctype">external
DTD subset</termref>, or to some other <termref def="dt-extent">external parameter
entity</termref>. Attempts to
retrieve the resource identified by a URI &may; be redirected at the parser
level (for example, in an entity resolver) or below (at the protocol level,
for example, via an HTTP <code>Location:</code> header). In the absence of additional
information outside the scope of this specification within the resource,
the base URI of a resource is always the URI of the actual resource returned.
In other words, it is the URI of the resource retrieved after all redirection
has occurred.</p>
					<p>System
identifiers (and other XML strings meant to be used as URI references) &may; contain
characters that, according to <bibref ref="rfc3986" diff="chg"/><phrase diff="del"><loc role="erratumref" href="E22"/> and <bibref ref="rfc2732"/></phrase>,
must be escaped before a URI can be used to retrieve the referenced resource. The
characters to be escaped are the control characters #x0 to #x1F and #x7F (most of
which cannot appear in XML), space #x20, the delimiters '&lt;' #x3C, '&gt;' #x3E and
'"' #x22, the <emph>unwise</emph> characters '{' #x7B, '}' #x7D, '|' #x7C, '\' #x5C, '^' #x5E and
'`' #x60, as well as all characters above #x7F. Since escaping is not always a fully
reversible process, it <rfc2119>MUST</rfc2119> be performed only when absolutely necessary and as late
as possible in a processing chain. In particular, neither the process of converting
a relative URI to an absolute one nor the process of passing a URI reference to a
process or software component responsible for dereferencing it <rfc2119>SHOULD</rfc2119> trigger escaping.
When escaping does occur, it <rfc2119>MUST</rfc2119> be performed as follows:</p>
					<olist>
						<item>
							<p>Each character to be escaped is represented in
UTF-8 <bibref ref="Unicode"/>
as one or more bytes.</p>
						</item>
						<item>
							<p>The resulting bytes are escaped with
the URI escaping mechanism (that is, converted to <code>%</code><var>HH</var>,
where HH is the hexadecimal notation of the byte value).</p>
						</item>
						<item>
							<p>The original character is replaced by the resulting character sequence.</p>
						</item>
					</olist>
					<p>
						<termdef id="dt-pubid" term="Public identifier"> In addition to a system
identifier, an external identifier &may; include a <term>public identifier</term>.</termdef>
An XML processor attempting to retrieve the entity's content &may; use
any combination of
the public and system identifiers as well as additional information outside the
scope of this specification to try to generate an alternative URI reference.
If the processor is unable to do so, it <rfc2119>MUST</rfc2119> use the URI
reference specified in the system literal. Before a match is attempted,
all strings of white space in the public identifier <rfc2119>MUST</rfc2119> be normalized to
single space characters (#x20), and leading and trailing white space <rfc2119>MUST</rfc2119>
be removed.</p>
					<p>Examples of external entity declarations:</p>
					<eg>&lt;!ENTITY open-hatch
SYSTEM "http://www.textuality.com/boilerplate/OpenHatch.xml"&gt;
&lt;!ENTITY open-hatch
PUBLIC "-//Textuality//TEXT Standard open-hatch boilerplate//EN"
"http://www.textuality.com/boilerplate/OpenHatch.xml"&gt;
&lt;!ENTITY hatch-pic
SYSTEM "../grafix/OpenHatch.gif"
NDATA gif &gt;</eg>
				</div3>
			</div2>
			<div2 id="TextEntities">
				<head>Parsed Entities</head>
				<div3 id="sec-TextDecl">
					<head>The Text Declaration</head>
					<p>External parsed entities <rfc2119>SHOULD</rfc2119> each begin with a <term>text declaration</term>.</p>
					<scrap lang="ebnf">
						<head>Text Declaration</head>
						<prodgroup pcw4="12.5" pcw5="13">
							<prod id="NT-TextDecl" num="77">
								<lhs>TextDecl</lhs>
								<rhs>'&lt;?xml' <nt def="NT-VersionInfo">VersionInfo</nt>? <nt def="NT-EncodingDecl">EncodingDecl</nt>
									<nt def="NT-S">S</nt>? '?>'</rhs>
							</prod>
						</prodgroup>
					</scrap>
					<p>The text declaration <rfc2119>MUST</rfc2119> be provided literally, not by reference
to a parsed entity. The text declaration
<rfc2119>MUST NOT</rfc2119> appear at any
position other than the beginning of an external parsed entity. The text declaration
in an external parsed entity is not considered part of its <termref def="dt-repltext">replacement text</termref>.</p>
				</div3>
				<div3 id="wf-entities">
					<head>Well-Formed Parsed Entities</head>
					<p>The document entity is well-formed if it matches the production labeled <nt def="NT-document">document</nt>. An external general parsed entity is well-formed
if it matches the production labeled <nt def="NT-extParsedEnt">extParsedEnt</nt>. All
external parameter entities are well-formed by definition.</p>
					<note diff="add">
						<p>
							<loc role="erratumref" href="E14"/>Only parsed entities that are referenced directly or indirectly within the document are required to be well-formed.</p>
					</note>
					<scrap lang="ebnf">
						<head>Well-Formed External Parsed Entity</head>
						<prod id="NT-extParsedEnt" num="78">
							<lhs>extParsedEnt</lhs>
							<rhs>
								<phrase diff="add">
									<loc role="erratumref" href="E02"/>(</phrase>
								<nt def="NT-TextDecl">TextDecl</nt>? <nt def="NT-content">content</nt>
								<phrase diff="add">
									<loc role="erratumref" href="E02"/>)</phrase> - <phrase diff="add">
									<loc role="erratumref" href="E02"/>(</phrase>
								<nt def="NT-Char">Char</nt>* <nt def="NT-RestrictedChar">RestrictedChar</nt>
								<nt def="NT-Char">Char</nt>*<phrase diff="add">
									<loc role="erratumref" href="E02"/>)</phrase>
							</rhs>
						</prod>
					</scrap>
					<p>An internal general parsed entity is well-formed if its replacement text
matches the production labeled <nt def="NT-content">content</nt>. All internal
parameter entities are well-formed by definition.</p>
					<p>A consequence of well-formedness in general
entities is that the logical and physical
structures in an XML document are properly nested; no <termref def="dt-stag">start-tag</termref>, <termref def="dt-etag">end-tag</termref>, <termref def="dt-empty">empty-element tag</termref>, <termref def="dt-element">element</termref>, <termref def="dt-comment">comment</termref>, <termref def="dt-pi">processing instruction</termref>, <termref def="dt-charref">character
reference</termref>, or <termref def="dt-entref">entity reference</termref>
can begin in one entity and end in another.</p>
				</div3>
				<div3 id="charencoding">
					<head>Character Encoding in Entities</head>
					<p>Each external parsed entity in an XML document &may; use a different encoding
for its characters. All XML processors <rfc2119>MUST</rfc2119> be able to read entities in both
the UTF-8 and UTF-16 encodings. The terms <quote>UTF-8</quote>
and <quote>UTF-16</quote> in this specification do not apply to character
encodings with any other labels, even if the encodings or labels are very
similar to UTF-8 or UTF-16.</p>
					<p>Entities encoded in UTF-16 <rfc2119>MUST</rfc2119> and entities
encoded in UTF-8 &MAY; begin with the Byte Order Mark described in
ISO/IEC 10646 <bibref ref="ISO10646"/> or Unicode <bibref ref="Unicode"/>
(the ZERO WIDTH NO-BREAK SPACE character, #xFEFF). This is an encoding signature,
not part of either the markup or the character data of the XML document. XML
processors <rfc2119>MUST</rfc2119> be able to use this character to differentiate between UTF-8
and UTF-16 encoded documents.</p>
					<p>Although an XML processor is required to read only entities in the UTF-8
and UTF-16 encodings, it is recognized that other encodings are used around
the world, and it may be desired for XML processors to read entities that
use them. In
the absence of external character encoding information (such as MIME headers),
parsed entities which are stored in an encoding other than UTF-8 or UTF-16
<rfc2119>MUST</rfc2119> begin with a text declaration (see <specref ref="sec-TextDecl"/>) containing
an encoding declaration:</p>
					<scrap lang="ebnf">
						<head>Encoding Declaration</head>
						<prod id="NT-EncodingDecl" num="80">
							<lhs>EncodingDecl</lhs>
							<rhs>
								<nt def="NT-S">S</nt> 'encoding' <nt def="NT-Eq">Eq</nt>
('"' <nt def="NT-EncName">EncName</nt> '"' | "'" <nt def="NT-EncName">EncName</nt>
"'" ) </rhs>
						</prod>
						<prod id="NT-EncName" num="81">
							<lhs>EncName</lhs>
							<rhs>[A-Za-z] ([A-Za-z0-9._] | '-')*</rhs>
							<com>Encoding
name contains only Latin characters</com>
						</prod>
					</scrap>
					<p>In the <termref def="dt-docent">document entity</termref>, the encoding
declaration is part of the <termref def="dt-xmldecl">XML declaration</termref>.
The <nt def="NT-EncName">EncName</nt> is the name of the encoding used.</p>
					<!-- FINAL EDIT: check name of IANA and charset names -->
					<p>In an encoding declaration, the values <quote><code>UTF-8</code></quote>, <quote><code>UTF-16</code></quote>,
<quote><code>ISO-10646-UCS-2</code></quote>, and <quote><code>ISO-10646-UCS-4</code></quote>
						<rfc2119>SHOULD</rfc2119> be used
for the various encodings and transformations of Unicode / ISO/IEC 10646,
the values <quote><code>ISO-8859-1</code></quote>, <quote><code>ISO-8859-2</code></quote>,
... <quote><code>ISO-8859-</code><var>n</var></quote> (where <var>n</var>
is the part number) <rfc2119>SHOULD</rfc2119> be used for the parts of ISO 8859, and
the values <quote><code>ISO-2022-JP</code></quote>, <quote><code>Shift_JIS</code></quote>,
and <quote><code>EUC-JP</code></quote>
						<rfc2119>SHOULD</rfc2119> be used for the various encoded
forms of JIS X-0208-1997. It
is <rfc2119>RECOMMENDED</rfc2119> that character encodings registered (as <emph>charset</emph>s)
with the Internet Assigned Numbers Authority <bibref ref="IANA"/>,
other than those just listed, be referred to using their registered names;
other encodings <rfc2119>SHOULD</rfc2119> use names starting with an <quote>x-</quote> prefix.
XML processors <rfc2119>SHOULD</rfc2119> match character encoding names in a case-insensitive
way and <rfc2119>SHOULD</rfc2119> either interpret an IANA-registered name as the encoding registered
at IANA for that name or treat it as unknown (processors are, of course, not
required to support all IANA-registered encodings).</p>
					<p>In the absence of information provided by an external transport protocol
(e.g. HTTP or MIME), it is a <termref def="dt-fatal">fatal error</termref> for
an entity including an encoding declaration to be presented to the XML processor
in an encoding other than that named in the declaration, or for an entity which
begins with neither a Byte Order Mark
nor an encoding declaration to use an encoding other than UTF-8. Note that
since ASCII is a subset of UTF-8, ordinary ASCII entities do not strictly
need an encoding declaration.</p>
					<p>It is a <termref def="dt-fatal">fatal error</termref> for a <nt def="NT-TextDecl">TextDecl</nt> to occur other
than at the beginning of an external entity.</p>
					<p>It is a <termref def="dt-fatal">fatal error</termref> when an XML processor
encounters an entity with an encoding that it is unable to process. It
is a <termref def="dt-fatal">fatal error</termref> if an XML entity is determined (via default, encoding declaration,
or higher-level protocol) to be in a certain encoding but contains byte
sequences that are not legal in that encoding. Specifically, it is a
fatal error if an entity encoded in UTF-8 contains any irregular code unit sequences,
as defined in Unicode <bibref ref="Unicode"/>. Unless an encoding
is determined by a higher-level protocol, it is also a <termref def="dt-fatal">fatal error</termref> if an XML entity
contains no encoding declaration and its content is not legal UTF-8 or UTF-16.</p>
					<p>Examples of text declarations containing encoding declarations:</p>
					<eg>&lt;?xml encoding='UTF-8'?&gt;
&lt;?xml encoding='EUC-JP'?&gt;</eg>
				</div3>
				<div3 id="sec-version-info">
					<head>Version Information in Entities</head>
					<p>Each entity, including the <termref def="dt-docent">document entity</termref>,
can be separately
declared as XML 1.0 or XML 1.1. The version declaration appearing
in the document entity determines the version of the document as a
whole. An XML 1.1 document may invoke XML 1.0 external entities, so
that otherwise duplicated versions of external entities,
particularly DTD external subsets, need not be maintained. However,
in such a case the rules of XML 1.1 are applied to the entire
document.</p>
					<p> If an entity (including the document entity) is not labeled
with a version number, it is treated as if labeled as version
1.0.</p>
				</div3>
			</div2>
			<div2 id="entproc">
				<head>XML Processor Treatment of Entities and References</head>
				<p>The table below summarizes the contexts in which character references,
entity references, and invocations of unparsed entities might appear and the
<rfc2119>REQUIRED</rfc2119> behavior of an <termref def="dt-xml-proc">XML processor</termref>
in each case. The labels in the leftmost column describe the recognition context: <glist>
						<gitem>
							<label>Reference in Content</label>
							<def>
								<p>as a reference anywhere after the <termref def="dt-stag">start-tag</termref>
and before the <termref def="dt-etag">end-tag</termref> of an element; corresponds
to the nonterminal <nt def="NT-content">content</nt>.</p>
							</def>
						</gitem>
						<gitem>
							<label>Reference in Attribute Value</label>
							<def>
								<p>as a reference within either the value of an attribute in a <termref def="dt-stag">start-tag</termref>,
or a default value in an <termref def="dt-attdecl">attribute declaration</termref>;
corresponds to the nonterminal <nt def="NT-AttValue">AttValue</nt>.</p>
							</def>
						</gitem>
						<gitem>
							<label>Occurs as Attribute Value</label>
							<def>
								<p>as a <nt def="NT-Name">Name</nt>, not a reference, appearing either as
the value of an attribute which has been declared as type <kw>ENTITY</kw>,
or as one of the space-separated tokens in the value of an attribute which
has been declared as type <kw>ENTITIES</kw>.</p>
							</def>
						</gitem>
						<gitem>
							<label>Reference in Entity Value</label>
							<def>
								<p>as a reference within a parameter or internal entity's <termref def="dt-litentval">literal
entity value</termref> in the entity's declaration; corresponds to the nonterminal <nt def="NT-EntityValue">EntityValue</nt>.</p>
							</def>
						</gitem>
						<gitem>
							<label>Reference in DTD</label>
							<def>
								<p>as a reference within either the internal or external subsets of the <termref def="dt-doctype">DTD</termref>, but outside of an <nt def="NT-EntityValue">EntityValue</nt>, <nt def="NT-AttValue">AttValue</nt>, <nt def="NT-PI">PI</nt>, <nt def="NT-Comment">Comment</nt>, <nt def="NT-SystemLiteral">SystemLiteral</nt>, <nt def="NT-PubidLiteral">PubidLiteral</nt>,
or the contents of an ignored conditional section (see <specref ref="sec-condition-sect"/>).</p>
								<p>.</p>
							</def>
						</gitem>
					</glist>
				</p>
				<table border="1" frame="border" cellpadding="7" summary="Entity type/reference matrix">
					<tbody align="center">
						<tr>
							<td rowspan="2" colspan="1"/>
							<td colspan="4" align="center" valign="bottom">Entity
Type</td>
							<td rowspan="2" align="center">Character</td>
						</tr>
						<tr align="center" valign="bottom">
							<td>Parameter</td>
							<td>Internal General</td>
							<td>External Parsed
General</td>
							<td>Unparsed</td>
						</tr>
						<tr align="center" valign="middle">
							<td align="right">Reference
in Content</td>
							<td>
								<titleref href="#not-recognized">Not recognized</titleref>
							</td>
							<td>
								<titleref href="#included">Included</titleref>
							</td>
							<td>
								<titleref href="#include-if-valid">Included
if validating</titleref>
							</td>
							<td>
								<titleref href="#forbidden">Forbidden</titleref>
							</td>
							<td>
								<titleref href="#included">Included</titleref>
							</td>
						</tr>
						<tr align="center" valign="middle">
							<td align="right">Reference in Attribute Value</td>
							<td>
								<titleref href="#not-recognized">Not recognized</titleref>
							</td>
							<td>
								<titleref href="#inliteral">Included
in literal</titleref>
							</td>
							<td>
								<titleref href="#forbidden">Forbidden</titleref>
							</td>
							<td>
								<titleref href="#forbidden">Forbidden</titleref>
							</td>
							<td>
								<titleref href="#included">Included</titleref>
							</td>
						</tr>
						<tr align="center" valign="middle">
							<td align="right">Occurs as Attribute
Value</td>
							<td>
								<titleref href="#not-recognized">Not recognized</titleref>
							</td>
							<td>
								<titleref href="#forbidden">Forbidden</titleref>
							</td>
							<td>
								<titleref href="#forbidden">Forbidden</titleref>
							</td>
							<td>
								<titleref href="#notify">Notify</titleref>
							</td>
							<td>
								<titleref href="#not-recognized">Not recognized</titleref>
							</td>
						</tr>
						<tr align="center" valign="middle">
							<td align="right">Reference in EntityValue</td>
							<td>
								<titleref href="#inliteral">Included in literal</titleref>
							</td>
							<td>
								<titleref href="#bypass">Bypassed</titleref>
							</td>
							<td>
								<titleref href="#bypass">Bypassed</titleref>
							</td>
							<td>
								<titleref href="#error">Error</titleref>
							</td>
							<td>
								<titleref href="#included">Included</titleref>
							</td>
						</tr>
						<tr align="center" valign="middle">
							<td align="right">Reference in DTD</td>
							<td>
								<titleref href="#as-PE">Included as PE</titleref>
							</td>
							<td>
								<titleref href="#forbidden">Forbidden</titleref>
							</td>
							<td>
								<titleref href="#forbidden">Forbidden</titleref>
							</td>
							<td>
								<titleref href="#forbidden">Forbidden</titleref>
							</td>
							<td>
								<titleref href="#forbidden">Forbidden</titleref>
							</td>
						</tr>
					</tbody>
				</table>
				<div3 id="not-recognized">
					<head>Not Recognized</head>
					<p>Outside the DTD, the <code>%</code> character has no special significance;
thus, what would be parameter entity references in the DTD are not recognized
as markup in <nt def="NT-content">content</nt>. Similarly, the names of unparsed
entities are not recognized except when they appear in the value of an appropriately
declared attribute.</p>
				</div3>
				<div3 id="included">
					<head>Included</head>
					<p>
						<termdef id="dt-include" term="Include">An entity is <term>included</term>
when its <termref def="dt-repltext">replacement text</termref> is retrieved
and processed, in place of the reference itself, as though it were part of
the document at the location the reference was recognized.</termdef> The replacement
text &may; contain both <termref def="dt-chardata">character data</termref>
and (except for parameter entities) <termref def="dt-markup">markup</termref>,
which <rfc2119>MUST</rfc2119> be recognized in the usual way. (The string <quote><code>AT&amp;amp;T;</code></quote>
expands to <quote><code>AT&amp;T;</code></quote> and the remaining ampersand
is not recognized as an entity-reference delimiter.) A character reference
is <term>included</term> when the indicated character is processed in place
of the reference itself. </p>
				</div3>
				<div3 id="include-if-valid">
					<head>Included If Validating</head>
					<p>When an XML processor recognizes a reference to a parsed entity, in order
to <termref def="dt-valid">validate</termref> the document, the processor
<rfc2119>MUST</rfc2119>
						<termref def="dt-include">include</termref> its replacement text. If
the entity is external, and the processor is not attempting to validate the
XML document, the processor &MAY;, but need
not, include the entity's replacement text. If a non-validating processor
does not include the replacement text, it <rfc2119>MUST</rfc2119> inform the application that
it recognized, but did not read, the entity.</p>
					<p>This rule is based on the recognition that the automatic inclusion provided
by the SGML and XML entity mechanism, primarily designed to support modularity
in authoring, is not necessarily appropriate for other applications, in particular
document browsing. Browsers, for example, when encountering an external parsed
entity reference, might choose to provide a visual indication of the entity's
presence and retrieve it for display only on demand.</p>
				</div3>
				<div3 id="forbidden">
					<head>Forbidden</head>
					<p>The following are forbidden, and constitute <termref def="dt-fatal">fatal
errors</termref>:</p>
					<ulist>
						<item>
							<p>the appearance of a reference to an <termref def="dt-unparsed">unparsed
entity</termref>, except in the
<nt def="NT-EntityValue">EntityValue</nt> in an entity declaration.</p>
						</item>
						<item>
							<p>the appearance of any character or general-entity reference in the
DTD except within an <nt def="NT-EntityValue">EntityValue</nt> or <nt def="NT-AttValue">AttValue</nt>.</p>
						</item>
						<item>
							<p>a reference to an external entity in an attribute value.</p>
						</item>
					</ulist>
				</div3>
				<div3 id="inliteral">
					<head>Included in Literal</head>
					<p>When an <termref def="dt-entref">entity reference</termref> appears in
an attribute value, or a parameter entity reference appears in a literal entity
value, its <termref def="dt-repltext">replacement text</termref>
						<rfc2119>MUST</rfc2119> be processed
in place of the reference itself as though it were part of the document at
the location the reference was recognized, except that a single or double
quote character in the replacement text <rfc2119>MUST</rfc2119> always be treated as a normal data
character and <rfc2119>MUST NOT</rfc2119> terminate the literal. For example, this is well-formed:</p>
					<eg><![CDATA[<!ENTITY % YN '"Yes"' >
<!ENTITY WhatHeSaid "He said %YN;" >]]></eg>
					<p>while this is not:</p>
					<eg>&lt;!ENTITY EndAttr "27'" &gt;
&lt;element attribute='a-&amp;EndAttr;&gt;</eg>
				</div3>
				<div3 id="notify">
					<head>Notify</head>
					<p>When the name of an <termref def="dt-unparsed">unparsed entity</termref>
appears as a token in the value of an attribute of declared type <kw>ENTITY</kw>
or <kw>ENTITIES</kw>, a validating processor <rfc2119>MUST</rfc2119> inform the application of
the <termref def="dt-sysid">system</termref> and <termref def="dt-pubid">public</termref>
(if any) identifiers for both the entity and its associated <termref def="dt-notation">notation</termref>.</p>
				</div3>
				<div3 id="bypass">
					<head>Bypassed</head>
					<p>When a general entity reference appears in the <nt def="NT-EntityValue">EntityValue</nt>
in an entity declaration, it <rfc2119>MUST</rfc2119> be bypassed and left as is.</p>
				</div3>
				<div3 id="as-PE">
					<head>Included as PE</head>
					<p>Just as with external parsed entities, parameter entities need only be <titleref href="#include-if-valid">included if validating</titleref>. When a parameter-entity
reference is recognized in the DTD and included, its <termref def="dt-repltext">replacement
text</termref>
						<rfc2119>MUST</rfc2119> be enlarged by the attachment of one leading and one following
space (#x20) character; the intent is to constrain the replacement text of
parameter entities to contain an integral number of grammatical tokens in
the DTD. This
behavior <rfc2119>MUST NOT</rfc2119> apply to parameter entity references within entity values;
these are described in <specref ref="inliteral"/>.</p>
				</div3>
				<div3 id="error">
					<head>Error</head>
					<p>It is an <termref def="dt-error">error</termref> for a reference to
an unparsed entity to appear in the <nt def="NT-EntityValue">EntityValue</nt> in an
entity declaration.</p>
				</div3>
			</div2>
			<div2 id="intern-replacement">
				<head>Construction of Entity Replacement Text</head>
				<p>In discussing the treatment of entities, it is useful to distinguish
two forms of the entity's value.
<termdef id="dt-litentval" term="Literal Entity Value">For an
internal entity, the <term>literal
entity value</term> is the quoted string actually present in the entity declaration,
corresponding to the non-terminal <nt def="NT-EntityValue">EntityValue</nt>.</termdef>
					<termdef id="dt-extlitentval" term="Literal Entity Value">For an external entity, the <term>literal
entity value</term> is the exact text contained in the entity.</termdef>
					<termdef id="dt-repltext" term="Replacement Text">For an
internal entity, the <term>replacement text</term>
is the content of the entity, after replacement of character references and
parameter-entity references.</termdef>
					<termdef id="dt-extrepltext" term="Replacement Text">For
an external entity, the <term>replacement text</term> is the content of the entity,
after stripping the text declaration (leaving any surrounding white space) if there
is one but without any replacement of character references or parameter-entity
references.</termdef>
				</p>
				<p>The literal entity value as given in an internal entity declaration (<nt def="NT-EntityValue">EntityValue</nt>) &may; contain character, parameter-entity,
and general-entity references. Such references <rfc2119>MUST</rfc2119> be contained entirely
within the literal entity value. The actual replacement text that is <termref def="dt-include">included</termref> (or <termref def="inliteral">included in literal</termref>) as described above
<rfc2119>MUST</rfc2119> contain the <emph>replacement
text</emph> of any parameter entities referred to, and <rfc2119>MUST</rfc2119> contain the character
referred to, in place of any character references in the literal entity value;
however, general-entity references <rfc2119>MUST</rfc2119> be left as-is, unexpanded. For example,
given the following declarations:</p>
				<eg><![CDATA[<!ENTITY % pub    "&#xc9;ditions Gallimard" >
<!ENTITY   rights "All rights reserved" >
<!ENTITY   book   "La Peste: Albert Camus,
&#xA9; 1947 %pub;. &rights;" >]]></eg>
				<p>then the replacement text for the entity <quote><code>book</code></quote>
is:</p>
				<eg>La Peste: Albert Camus,
&#xA9; 1947 &#xC9;ditions Gallimard. &amp;rights;</eg>
				<p>The general-entity reference <quote><code>&amp;rights;</code></quote> would
be expanded should the reference <quote><code>&amp;book;</code></quote> appear
in the document's content or an attribute value.</p>
				<p>These simple rules may have complex interactions; for a detailed discussion
of a difficult example, see <specref ref="sec-entexpand"/>.</p>
			</div2>
			<div2 id="sec-predefined-ent">
				<head>Predefined Entities</head>
				<p>
					<termdef id="dt-escape" term="escape">Entity and character references &may;
both be used to <term>escape</term> the left angle bracket, ampersand, and
other delimiters. A set of general entities (&magicents;) is specified for
this purpose. Numeric character references &may; also be used; they are expanded
immediately when recognized and <rfc2119>MUST</rfc2119> be treated as character data, so the
numeric character references <quote><code>&amp;#60;</code></quote> and <quote><code>&amp;#38;</code></quote> &may; be used to escape <code>&lt;</code> and <code>&amp;</code> when they occur
in character data.</termdef>
				</p>
				<p>All XML processors <rfc2119>MUST</rfc2119> recognize these entities whether they are declared
or not. <termref def="dt-interop">For interoperability</termref>, valid XML
documents <rfc2119>SHOULD</rfc2119> declare these entities, like any others, before using them. If
the entities <code>lt</code> or <code>amp</code> are declared, they <rfc2119>MUST</rfc2119> be
declared as internal entities whose replacement text is a character reference
to the respective
character (less-than sign or ampersand) being escaped; the double
escaping is <rfc2119>REQUIRED</rfc2119> for these entities so that references to them produce
a well-formed result. If the entities <code>gt</code>, <code>apos</code>,
or <code>quot</code> are declared, they <rfc2119>MUST</rfc2119> be declared as internal entities
whose replacement text is the single character being escaped (or a character
reference to that character; the double escaping here is <rfc2119>OPTIONAL</rfc2119> but harmless).
For example:</p>
				<eg><![CDATA[<!ENTITY lt     "&#38;#60;">
<!ENTITY gt     "&#62;">
<!ENTITY amp    "&#38;#38;">
<!ENTITY apos   "&#39;">
<!ENTITY quot   "&#34;">]]></eg>
			</div2>
			<div2 id="Notations">
				<head>Notation Declarations</head>
				<p>
					<termdef id="dt-notation" term="Notation">
						<term>Notations</term> identify
by name the format of <termref def="dt-unparsed">unparsed entities</termref>,
the format of elements which bear a notation attribute, or the application
to which a <termref def="dt-pi">processing instruction</termref> is addressed.</termdef>
				</p>
				<p>
					<termdef id="dt-notdecl" term="Notation Declaration">
						<term>Notation declarations</term>
provide a name for the notation, for use in entity and attribute-list declarations
and in attribute specifications, and an external identifier for the notation
which may allow an XML processor or its client application to locate a helper
application capable of processing data in the given notation.</termdef>
				</p>
				<scrap lang="ebnf">
					<head>Notation Declarations</head>
					<prod id="NT-NotationDecl" num="82">
						<lhs>NotationDecl</lhs>
						<rhs>'&lt;!NOTATION' <nt def="NT-S">S</nt>
							<nt def="NT-Name">Name</nt>
							<nt def="NT-S">S</nt> (<nt def="NT-ExternalID">ExternalID</nt> | <nt def="NT-PublicID">PublicID</nt>) <nt def="NT-S">S</nt>? '&gt;'</rhs>
						<vc def="UniqueNotationName"/>
					</prod>
					<prod id="NT-PublicID" num="83">
						<lhs>PublicID</lhs>
						<rhs>'PUBLIC' <nt def="NT-S">S</nt>
							<nt def="NT-PubidLiteral">PubidLiteral</nt>
						</rhs>
					</prod>
				</scrap>
				<vcnote id="UniqueNotationName">
					<head>Unique Notation Name</head>
					<p>A given <nt def="NT-Name">Name</nt>
						<rfc2119>MUST NOT</rfc2119> be declared in more than one notation declaration.</p>
				</vcnote>
				<p>XML processors <rfc2119>MUST</rfc2119> provide applications with the name and external identifier(s)
of any notation declared and referred to in an attribute value, attribute
definition, or entity declaration. They &MAY; additionally resolve the external
identifier into the <termref def="dt-sysid">system identifier</termref>, file
name, or other information needed to allow the application to call a processor
for data in the notation described. (It is not an error, however, for XML
documents to declare and refer to notations for which notation-specific applications
are not available on the system where the XML processor or application is
running.)</p>
			</div2>
			<div2 id="sec-doc-entity">
				<head>Document Entity</head>
				<p>
					<termdef id="dt-docent" term="Document Entity">The <term>document entity</term>
serves as the root of the entity tree and a starting-point for an <termref def="dt-xml-proc">XML processor</termref>.</termdef> This specification does
not specify how the document entity is to be located by an XML processor;
unlike other entities, the document entity has no name and might well appear
on a processor input stream without any identification at all.</p>
			</div2>
		</div1>
		<!-- &Conformance; -->
		<div1 id="sec-conformance">
			<head>Conformance</head>
			<div2 id="proc-types">
				<head>Validating and Non-Validating Processors</head>
				<p>Conforming <termref def="dt-xml-proc">XML processors</termref> fall into
two classes: validating and non-validating.</p>
				<p>Validating and non-validating processors alike <rfc2119>MUST</rfc2119> report violations of
this specification's well-formedness constraints in the content of the <termref def="dt-docent">document entity</termref> and any other <termref def="dt-parsedent">parsed
entities</termref> that they read.</p>
				<p>
					<termdef id="dt-validating" term="Validating Processor">
						<term>Validating
processors</term>
						<rfc2119>MUST</rfc2119>,
at user option, report violations of the constraints expressed by
the declarations in the <termref def="dt-doctype">DTD</termref>, and failures
to fulfill the validity constraints given in this specification.</termdef>
To accomplish this, validating XML processors <rfc2119>MUST</rfc2119> read and process the entire
DTD and all external parsed entities referenced in the document.</p>
				<p>Non-validating processors are <rfc2119>REQUIRED</rfc2119> to check only the <termref def="dt-docent">document
entity</termref>, including the entire internal DTD subset, for well-formedness. <termdef id="dt-use-mdecl" term="Process Declarations"> While they are not required
to check the document for validity, they are <rfc2119>REQUIRED</rfc2119> to <term>process</term>
all the declarations they read in the internal DTD subset and in any parameter
entity that they read, up to the first reference to a parameter entity that
they do <emph>not</emph> read; that is to say, they <rfc2119>MUST</rfc2119> use the information
in those declarations to <titleref href="#AVNormalize">normalize</titleref>
attribute values, <titleref href="#included">include</titleref> the replacement
text of internal entities, and supply <titleref href="#sec-attr-defaults">default
attribute values</titleref>.</termdef> Except when <code>standalone="yes"</code>, they
<rfc2119>MUST NOT</rfc2119>
					<termref def="dt-use-mdecl">process</termref>
					<termref def="dt-entdecl">entity
declarations</termref> or <termref def="dt-attdecl">attribute-list declarations</termref>
encountered after a reference to a parameter entity that is not read, since
the entity may have contained overriding declarations; when <code>standalone="yes"</code>, processors <rfc2119>MUST</rfc2119>
process these declarations.</p>
				<p>Note
that when processing invalid documents with a non-validating
processor the application may not be presented with consistent
information.  For example, several requirements for uniqueness
within the document may not be met, including more than one element
with the same id, duplicate declarations of elements or notations
with the same name, etc.  In these cases the behavior of the parser
with respect to reporting such information to the application is
undefined.</p>
				<p>XML 1.1 processors <rfc2119>MUST</rfc2119> be able to process both XML 1.0
and XML 1.1 documents.  Programs which generate XML <rfc2119>SHOULD</rfc2119>
generate XML 1.0, unless one of the specific features of XML 1.1 is required.</p>
			</div2>
			<div2 id="safe-behavior">
				<head>Using XML Processors</head>
				<p>The behavior of a validating XML processor is highly predictable; it must
read every piece of a document and report all well-formedness and validity
violations. Less is required of a non-validating processor; it need not read
any part of the document other than the document entity. This has two effects
that may be important to users of XML processors:</p>
				<ulist>
					<item>
						<p>Certain well-formedness errors, specifically those that require reading
external entities, may fail to be detected by a non-validating processor. Examples
include the constraints entitled <titleref href="#wf-entdeclared">Entity Declared</titleref>, <titleref href="#textent">Parsed Entity</titleref>, and <titleref href="#norecursion">No
Recursion</titleref>, as well as some of the cases described as <titleref href="#forbidden">forbidden</titleref> in <specref ref="entproc"/>.</p>
					</item>
					<item>
						<p>The information passed from the processor to the application may
vary, depending on whether the processor reads parameter and external entities.
For example, a non-validating processor may fail to <titleref href="#AVNormalize">normalize</titleref>
attribute values, <titleref href="#included">include</titleref> the replacement
text of internal entities, or supply <titleref href="#sec-attr-defaults">default
attribute values</titleref>, where doing so depends on having read declarations
in external or parameter entities.</p>
					</item>
				</ulist>
				<p>For maximum reliability in interoperating between different XML processors,
applications which use non-validating processors <rfc2119>SHOULD NOT</rfc2119> rely on any behaviors
not required of such processors.  Applications which require DTD facilities
not related to validation (such
as the declaration of default attributes and internal entities that are
or may be specified in
external entities<phrase diff="add">
						<loc role="erratumref" href="E09"/>)</phrase>
					<rfc2119>SHOULD</rfc2119> use validating XML processors.</p>
			</div2>
		</div1>
		<div1 id="sec-notation">
			<head>Notation</head>
			<p>The formal grammar of XML is given in this specification using a simple
Extended Backus-Naur Form (EBNF) notation. Each rule in the grammar defines
one symbol, in the form</p>
			<eg>symbol ::= expression</eg>
			<p>Symbols are written with an initial capital letter if they are the
start symbol of a regular language, otherwise with an initial lowercase
letter. Literal strings are quoted.</p>
			<p>Within the expression on the right-hand side of a rule, the following expressions
are used to match strings of one or more characters: <glist>
					<gitem>
						<label>
							<code>#xN</code>
						</label>
						<def>
							<p>where <code>N</code> is a hexadecimal integer, the expression matches the character
whose number
(code point) in ISO/IEC 10646 is <code>N</code>. The number of leading zeros in the <code>#xN</code>
form is insignificant.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>[a-zA-Z]</code>, <code>[#xN-#xN]</code>
						</label>
						<def>
							<p>matches any <nt def="NT-Char">Char</nt> with a value in the range(s) indicated (inclusive).</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>[abc]</code>, <code>[#xN#xN#xN]</code>
						</label>
						<def>
							<p>matches any <nt def="NT-Char">Char</nt> with a value among the characters
enumerated. Enumerations and ranges can be mixed in one set of brackets.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>[^a-z]</code>, <code>[^#xN-#xN]</code>
						</label>
						<def>
							<p>matches any <nt def="NT-Char">Char</nt> with a value <emph>outside</emph> the range
indicated.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>[^abc]</code>, <code>[^#xN#xN#xN]</code>
						</label>
						<def>
							<p>matches any <nt def="NT-Char">Char</nt> with a value not among the characters given. Enumerations
and ranges of forbidden values can be mixed in one set of brackets.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>"string"</code>
						</label>
						<def>
							<p>matches a literal string <termref def="dt-match">matching</termref> that
given inside the double quotes.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>'string'</code>
						</label>
						<def>
							<p>matches a literal string <termref def="dt-match">matching</termref> that
given inside the single quotes.</p>
						</def>
					</gitem>
				</glist> These symbols may be combined to match more complex patterns as follows,
where <code>A</code> and <code>B</code> represent simple expressions: <glist>
					<gitem>
						<label>(<code>expression</code>)</label>
						<def>
							<p>
								<code>expression</code> is treated as a unit and may be combined as described
in this list.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>A?</code>
						</label>
						<def>
							<p>matches <code>A</code> or nothing; optional <code>A</code>.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>A B</code>
						</label>
						<def>
							<p>matches <code>A</code> followed by <code>B</code>. This
operator has higher precedence than alternation; thus <code>A B | C D</code>
is identical to <code>(A B) | (C D)</code>.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>A | B</code>
						</label>
						<def>
							<p>matches <code>A</code> or <code>B</code>.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>A - B</code>
						</label>
						<def>
							<p>matches any string that matches <code>A</code> but does not match <code>B</code>.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>A+</code>
						</label>
						<def>
							<p>matches one or more occurrences of <code>A</code>. Concatenation
has higher precedence than alternation; thus <code>A+ | B+</code> is identical
to <code>(A+) | (B+)</code>.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>A*</code>
						</label>
						<def>
							<p>matches zero or more occurrences of <code>A</code>. Concatenation
has higher precedence than alternation; thus <code>A* | B*</code> is identical
to <code>(A*) | (B*)</code>.</p>
						</def>
					</gitem>
				</glist> Other notations used in the productions are: <glist>
					<gitem>
						<label>
							<code>/* ... */</code>
						</label>
						<def>
							<p>comment.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>[ wfc: ... ]</code>
						</label>
						<def>
							<p>well-formedness constraint; this identifies by name a constraint on <termref def="dt-wellformed">well-formed</termref> documents associated with a production.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>[ vc: ... ]</code>
						</label>
						<def>
							<p>validity constraint; this identifies by name a constraint on <termref def="dt-valid">valid</termref>
documents associated with a production.</p>
						</def>
					</gitem>
				</glist>
			</p>
		</div1>
	</body>
	<back>
		<!-- &SGML; -->
		<!-- &Biblio; -->
		<div1 id="sec-bibliography">
			<head>References</head>
			<div2 id="sec-existing-stds">
				<head>Normative References</head>
				<blist>
					<!--<bibl id="Charmod" href="http://www.w3.org/TR/charmod/">W3C. <titleref>Character Model for the World
Wide Web</titleref>.  Martin J. D&#FC;rst, Fran&#E7;ois Yergeau, Richard Ishida,
Misha Wolf, Asmus Freytag, Tex Texin.</bibl>-->
					<bibl id="IANA" href="http://www.iana.org/assignments/character-sets" key="IANA-CHARSETS">(Internet
Assigned Numbers Authority) <titleref>Official Names for Character Sets</titleref>,
ed. Keld Simonsen et al. </bibl>
					<bibl id="rfc2119" href="http://www.ietf.org/rfc/rfc2119.txt" key="IETF RFC 2119">IETF
(Internet Engineering Task Force). <titleref>RFC 2119: Key words for use in RFCs to Indicate Requirement Levels</titleref>.
Scott Bradner, 1997.</bibl>
					<bibl id="rfc2396" href="http://www.ietf.org/rfc/rfc2396.txt" key="IETF RFC 2396" diff="del"><loc role="erratumref" href="E22"/>IETF
(Internet Engineering Task Force). <titleref>RFC 2396: Uniform Resource Identifiers
(URI): Generic Syntax</titleref>. T. Berners-Lee, R. Fielding, L. Masinter.
1998.</bibl>
					<bibl id="rfc2732" href="http://www.ietf.org/rfc/rfc2732.txt" key="IETF RFC 2732" diff="del"><loc role="erratumref" href="E22"/>IETF
(Internet Engineering Task Force). <titleref>RFC 2732: Format for Literal
IPv6 Addresses in URL's</titleref>. R. Hinden, B. Carpenter, L. Masinter.
1999.</bibl>
					<bibl id="RFC1766" href="http://www.ietf.org/rfc/rfc3066.txt" key="IETF RFC 3066">IETF
(Internet Engineering Task Force). <titleref>RFC 3066: Tags for the Identification
of Languages</titleref>, ed. H. Alvestrand. 2001.</bibl>
					<bibl id="rfc3986" href="http://www.ietf.org/rfc/rfc3986.txt" key="IETF RFC 3986" diff="add"><loc role="erratumref" href="E22"/>IETF (Internet Engineering Task Force). <titleref>RFC 3986: Uniform Resource Identifier (URI): Generic Syntax</titleref>. T. Berners-Lee, R. Fielding, L. Masinter. 2005.</bibl>
					<bibl id="ISO10646" key="ISO/IEC 10646">ISO (International
Organization for Standardization). <titleref>ISO/IEC 10646-1:2000. Information
technology &mdash; Universal Multiple-Octet Coded Character Set (UCS) &mdash;
Part 1: Architecture and Basic Multilingual Plane</titleref> and <titleref>ISO/IEC 10646-2:2001.
Information technology &mdash; Universal Multiple-Octet Coded Character Set (UCS) &mdash; Part 2:
Supplementary Planes</titleref>, as, from time to time, amended, replaced by a new edition or
expanded by the addition of new parts. [Geneva]: International Organization for Standardization.
(See <loc href="http://www.iso.ch">http://www.iso.ch</loc> for the latest version.)</bibl>
					<bibl id="Unicode" key="Unicode">The Unicode Consortium. <emph>The Unicode
Standard, Version 4.0.</emph> Reading, Mass.: Addison-Wesley,
2003,
as updated from time to time by the publication of new versions. (See
<loc href="http://www.unicode.org/unicode/standard/versions">
http://www.unicode.org/unicode/standard/versions</loc> for the latest version
and additional information on versions of the standard and of the Unicode
Character Database).</bibl>
					<bibl id="XML1.0" href="http://www.w3.org/TR/xml" key="XML-1.0">W3C.  <titleref>Extensible Markup Language (XML) 1.0 (Fourth
Edition)</titleref>.  Tim Bray, Jean Paoli, C.M. Sperberg-McQueen, Eve Maler, Fran&#xE7;ois Yergeau
(editors)</bibl>
				</blist>
			</div2>
			<div2 id="null">
				<!--
ID made "null" to match its previous value in the First
Edition; it's odd, but if there's no set value, the stylesheet
currently generates an odd string that would be backwards
incompatible with any references anyone might have made before.
-->
				<head>Other References</head>
				<blist>
					<bibl id="Aho" key="Aho/Ullman">Aho, Alfred V., Ravi Sethi, and Jeffrey D.
Ullman. <titleref>Compilers: Principles, Techniques, and Tools</titleref>.
Reading: Addison-Wesley, 1986, rpt. corr. 1988.</bibl>
					<bibl id="ABK" href="ftp://ftp.informatik.uni-freiburg.de/documents/papers/brueggem/habil.ps" key="Br√ºggemann-Klein">Br√ºggemann-Klein,
Anne. <titleref>Formal Models in Document Processing</titleref>. Habilitationsschrift. Faculty
of Mathematics at the University of Freiburg, 1993.</bibl>
					<bibl id="ABKDW" key="Br√ºggemann-Klein and Wood">Br√ºggemann-Klein,
Anne, and Derick Wood. <titleref>Deterministic Regular Languages</titleref>.
Universit√§t Freiburg, Institut f√ºr Informatik, Bericht 38, Oktober 1991. Extended
abstract in A. Finkel, M. Jantzen, Hrsg., STACS 1992, S. 173-184. Springer-Verlag,
Berlin 1992. Lecture Notes in Computer Science 577. Full version titled <titleref>One-Unambiguous
Regular Languages</titleref> in Information and Computation 140 (2): 229-253,
February 1998.</bibl>
					<bibl id="Charmod" href="http://www.w3.org/TR/2003/WD-charmod-20030822/" key="Charmod">W3C Working Draft.
<titleref>Character Model for the World Wide Web 1.0</titleref>.
Martin J. D&#xFC;rst, Fran&#xE7;ois Yergeau, Richard Ishida, Misha Wolf, Tex Texin.</bibl>
					<bibl id="Clark" href="http://www.w3.org/TR/NOTE-sgml-xml-971215" key="Clark">James Clark.
<titleref>Comparison of SGML and XML</titleref>.</bibl>
					<bibl id="IANA-LANGCODES" href="http://www.iana.org/assignments/language-tags" key="IANA-LANGCODES">(Internet
Assigned Numbers Authority) <titleref>Registry of Language Tags</titleref>,
ed. Keld Simonsen et al. </bibl>
					<bibl id="RFC2141" href="http://www.ietf.org/rfc/rfc2141.txt" key="IETF RFC 2141">IETF
(Internet Engineering Task Force). <titleref>RFC 2141: URN Syntax</titleref>, ed.
R. Moats. 1997. </bibl>
					<bibl id="rfc2376" href="http://www.ietf.org/rfc/rfc3023.txt" key="IETF RFC 3023">IETF
(Internet Engineering Task Force). <titleref>RFC 3023: XML Media Types</titleref>.
eds. M. Murata, S. St.Laurent, D. Kohn. 2001.</bibl>
					<bibl id="rfc2781" href="http://www.ietf.org/rfc/rfc2781.txt" key="IETF RFC 2781">IETF
(Internet Engineering Task Force). <titleref>RFC 2781: UTF-16, an encoding
of ISO 10646</titleref>, ed. P. Hoffman, F. Yergeau. 2000.</bibl>
					<bibl id="ISO639" key="ISO 639">(International Organization for Standardization).
<titleref>ISO 639:1988 (E).
Code for the representation of names of languages.</titleref> [Geneva]: International
Organization for Standardization, 1988.</bibl>
					<bibl id="ISO3166" key="ISO 3166">(International Organization for Standardization).
<titleref>ISO 3166-1:1997
(E). Codes for the representation of names of countries and their subdivisions &mdash;
Part 1: Country codes</titleref> [Geneva]: International Organization for
Standardization, 1997.</bibl>
					<bibl id="ISO8879" key="ISO 8879">ISO (International Organization for Standardization). <titleref>ISO
8879:1986(E). Information processing &mdash; Text and Office Systems &mdash;
Standard Generalized Markup Language (SGML).</titleref> First edition &mdash;
1986-10-15. [Geneva]: International Organization for Standardization, 1986. </bibl>
					<bibl id="ISO10744" key="ISO/IEC 10744">ISO (International Organization for
Standardization). <titleref>ISO/IEC 10744-1992 (E). Information technology &mdash;
Hypermedia/Time-based Structuring Language (HyTime). </titleref> [Geneva]:
International Organization for Standardization, 1992. <emph>Extended Facilities
Annexe.</emph> [Geneva]: International Organization for Standardization, 1996. </bibl>
					<bibl id="websgml" href="http://www.sgmlsource.com/8879/n0029.htm" key="WEBSGML">ISO
(International Organization for Standardization). <titleref>ISO 8879:1986
TC2. Information technology &mdash; Document Description and Processing Languages</titleref>.
[Geneva]: International Organization for Standardization, 1998.</bibl>
					<bibl id="xml-names" href="http://www.w3.org/TR/REC-xml-names/" key="XML Names">Tim Bray,
Dave Hollander, and Andrew Layman, editors. <titleref>Namespaces in XML</titleref>.
Textuality, Hewlett-Packard, and Microsoft. World Wide Web Consortium, 1999.</bibl>
				</blist>
			</div2>
		</div1>
		<div1 id="sec-CharNorm">
			<head>Definitions for Character Normalization</head>
			<p>This appendix contains the necessary definitions for character normalization.
For additional background information and examples, see <bibref ref="Charmod"/>.</p>
			<p>
				<!-- from http://www.w3.org/TR/2003/WD-charmod-20030822/#sec-Digital -->
				<termdef term="Unicode encoding form" id="dt-Uni-encform">Text is said to be
in a <term>Unicode encoding form</term> if it is encoded in
UTF-8, UTF-16 or UTF-32.</termdef>
			</p>
			<p>
				<!-- from http://www.w3.org/TR/2003/WD-charmod-20030822/#sec-Background -->
				<termdef term="legacy encoding" id="dt-legacyenc">
					<term>Legacy encoding</term>
is taken to mean any character encoding not based on Unicode.</termdef>
			</p>
			<p>
				<!-- from http://www.w3.org/TR/2003/WD-charmod-20030822/#sec-Transcoding -->
				<termdef term="normalizing transcoder" id="dt-normtransc">A
<term>normalizing transcoder</term> is a transcoder that converts from a
<termref def="dt-legacyenc">legacy encoding</termref> to a
<termref def="dt-Uni-encform">Unicode encoding form</termref> and
ensures that the result is in Unicode Normalization Form C
(see UAX #15 <bibref ref="Unicode"/>).</termdef>
			</p>
			<p>
				<termdef term="character escape" id="dt-charesc">A <term>character escape</term>
is a syntactic device defined in a markup or programming language that allows
one or more of:</termdef>
			</p>
			<olist>
				<item>
					<p>expressing syntax-significant characters while disregarding
their significance in the syntax of the language, or</p>
				</item>
				<item>
					<p>expressing characters not representable in the character encoding
chosen for an instance of the language, or</p>
				</item>
				<item>
					<p>expressing characters in general, without use of the corresponding
character codes.</p>
				</item>
			</olist>
			<p>
				<!-- from http://www.w3.org/TR/2003/WD-charmod-20030822/#sec-NormalizationApplication -->
				<termdef term="certified" id="dt-certified">
					<term>Certified</term> text
is text which satisfies at least one of the following conditions:</termdef>
			</p>
			<olist>
				<item>
					<p>it has been confirmed through inspection that the text
is in normalized form</p>
				</item>
				<item>
					<p>the source text-processing component is identified
and is known to produce only normalized text.</p>
				</item>
			</olist>
			<p>
				<!-- from http://www.w3.org/TR/2003/WD-charmod-20030822/#sec-UnicodeNormalized -->
				<termdef term="Unicode-normalized" id="dt-uninorm">Text is, for the purposes of
this specification, <term>Unicode-normalized</term> if it is in a
<termref def="dt-Uni-encform">Unicode encoding form</termref> and is in
Unicode Normalization Form C, according to a version of Unicode Standard Annex #15:
Unicode Normalization Forms <bibref ref="Unicode"/> at least as recent as the
oldest version of the Unicode Standard that contains all the characters
actually present in the text, but no earlier
than version 3.2.</termdef>
			</p>
			<p>
				<!-- from http://www.w3.org/TR/2003/WD-charmod-20030822/#sec-IncludeNormalized -->
				<termdef term="include-normalized" id="dt-inclnorm">Text is
<term>include-normalized</term> if:</termdef>
			</p>
			<olist>
				<item>
					<p>the text is <termref def="dt-uninorm">Unicode-normalized</termref>
and does not contain any <termref def="dt-charesc">character escapes</termref>
or <termref def="dt-include">includes</termref> whose expansion would
cause the text to become no longer <termref def="dt-uninorm">Unicode-normalized</termref>;
or</p>
				</item>
				<item>
					<p>the text is in a <termref def="dt-legacyenc">legacy encoding</termref> and, if it were transcoded
to a <termref def="dt-Uni-encform">Unicode encoding form</termref> by a
<termref def="dt-normtransc">normalizing transcoder</termref>, the resulting
text would satisfy clause 1 above.</p>
				</item>
			</olist>
			<p>
				<!-- from http://www.w3.org/TR/2003/WD-charmod-20030822/#sec-FullyNormalized -->
				<termdef term="composing character" id="dt-compchar">A <term>composing character</term>
is a character that is one or both of the following:</termdef>
			</p>
			<olist>
				<item>
					<p>the second character in the canonical decomposition mapping of
some primary composite (as defined in D3 of UAX #15 <bibref ref="Unicode"/>), or</p>
				</item>
				<item>
					<p>of non-zero canonical combining class (as defined in Unicode
<bibref ref="Unicode"/>).</p>
				</item>
			</olist>
			<p>
				<!-- from http://www.w3.org/TR/2003/WD-charmod-20030822/#sec-FullyNormalized -->
				<termdef term="fully normalized" id="dt-fullnorm">Text is
<term>fully-normalized</term> if:</termdef>
			</p>
			<olist>
				<item>
					<p>the text is in a <termref def="dt-Uni-encform">Unicode encoding
form</termref>, is <termref def="dt-inclnorm">include-normalized</termref> and
none of the <termref def="dt-relconst">relevant
constructs</termref> comprising the text begin with a
<termref def="dt-compchar">composing character</termref> or a
character escape representing a
<termref def="dt-compchar">composing character</termref>; or</p>
				</item>
				<item>
					<p>the text is in a <termref def="dt-legacyenc">legacy encoding</termref> and,
if it were transcoded to a <termref def="dt-Uni-encform">Unicode encoding form</termref>
by a <termref def="dt-normtransc">normalizing transcoder</termref>, the resulting text
would satisfy clause 1 above.</p>
				</item>
			</olist>
		</div1>
		<inform-div1 id="sec-entexpand">
			<head>Expansion of Entity and Character References</head>
			<p>This appendix contains some examples illustrating the sequence of entity-
and character-reference recognition and expansion, as specified in <specref ref="entproc"/>.</p>
			<p>If the DTD contains the declaration</p>
			<eg><![CDATA[<!ENTITY example "<p>An ampersand (&#38;#38;) may be escaped
numerically (&#38;#38;#38;) or with a general entity
(&amp;amp;).</p>" >]]></eg>
			<p>then the XML processor will recognize the character references when it
parses the entity declaration, and resolve them before storing the following
string as the value of the entity <quote><code>example</code></quote>:</p>
			<eg><![CDATA[<p>An ampersand (&#38;) may be escaped
numerically (&#38;#38;) or with a general entity
(&amp;amp;).</p>]]></eg>
			<p>A reference in the document to <quote><code>&amp;example;</code></quote>
will cause the text to be reparsed, at which time the start- and end-tags
of the <el>p</el> element will be recognized and the three references will
be recognized and expanded, resulting in a <el>p</el> element with the following
content (all data, no delimiters or markup):</p>
			<eg><![CDATA[An ampersand (&) may be escaped
numerically (&#38;) or with a general entity
(&amp;).]]></eg>
			<p>A more complex example will illustrate the rules and their effects fully.
In the following example, the line numbers are solely for reference.</p>
			<eg><![CDATA[1 <?xml version='1.]]><phrase diff="chg"><loc role="erratumref" href="E06"/>1</phrase><![CDATA['?>
2 <!DOCTYPE test [
3 <!ELEMENT test (#PCDATA) >
4 <!ENTITY % xx '&#37;zz;'>
5 <!ENTITY % zz '&#60;!ENTITY tricky "error-prone" >' >
6 %xx;
7 ]>
8 <test>This sample shows a &tricky; method.</test>]]></eg>
			<p>This produces the following:</p>
			<ulist spacing="compact">
				<item>
					<p>in line 4, the reference to character 37 is expanded immediately,
and the parameter entity <quote><code>xx</code></quote> is stored in the symbol
table with the value <quote><code>%zz;</code></quote>. Since the replacement
text is not rescanned, the reference to parameter entity <quote><code>zz</code></quote>
is not recognized. (And it would be an error if it were, since <quote><code>zz</code></quote>
is not yet declared.)</p>
				</item>
				<item>
					<p>in line 5, the character reference <quote><code>&amp;#60;</code></quote>
is expanded immediately and the parameter entity <quote><code>zz</code></quote>
is stored with the replacement text
<quote><code>&lt;!ENTITY tricky "error-prone"&gt;</code></quote>, which is a well-formed entity declaration.</p>
				</item>
				<item>
					<p>in line 6, the reference to <quote><code>xx</code></quote> is recognized,
and the replacement text of <quote><code>xx</code></quote> (namely <quote><code>%zz;</code></quote>)
is parsed. The reference to <quote><code>zz</code></quote> is recognized in
its turn, and its replacement text
(<quote><code>&lt;!ENTITY tricky "error-prone"&gt;</code></quote>)
is parsed. The general entity <quote><code>tricky</code></quote>
has now been declared, with the replacement text <quote><code>error-prone</code></quote>.</p>
				</item>
				<item>
					<p>in line 8, the reference to the general entity <quote><code>tricky</code></quote>
is recognized, and it is expanded, so the full content of the <el>test</el>
element is the self-describing (and ungrammatical) string <emph>This sample
shows a error-prone method.</emph>
					</p>
				</item>
			</ulist>
		</inform-div1>
		<inform-div1 id="determinism">
			<head>Deterministic Content Models</head>
			<p>As
noted in <specref ref="sec-element-content"/>, it is required that content
models in element type declarations be deterministic. This requirement is <termref def="dt-compat">for compatibility</termref> with SGML (which calls deterministic
content models <quote>unambiguous</quote>); XML processors built
using SGML systems may flag non-deterministic content models as errors.</p>
			<p>For example, the content model <code>((b, c) | (b, d))</code> is non-deterministic,
because given an initial <el>b</el> the XML processor
cannot know which <el>b</el> in the model is being matched without looking
ahead to see which element follows the <el>b</el>. In this case, the two references
to <el>b</el> can be collapsed into a single reference, making the model read <code>(b,
(c | d))</code>. An initial <el>b</el> now clearly matches only a single name
in the content model. The processor doesn't need to look ahead to see what follows; either <el>c</el> or <el>d</el>
would be accepted.</p>
			<p>More formally: a finite state automaton may be constructed from the content
model using the standard algorithms, e.g. algorithm 3.5 in section 3.9 of
Aho, Sethi, and Ullman <bibref ref="Aho"/>. In many such algorithms, a follow
set is constructed for each position in the regular expression (i.e., each
leaf node in the syntax tree for the regular expression); if any position
has a follow set in which more than one following position is labeled with
the same element type name, then the content model is in error and may be
reported as an error.</p>
			<p>Algorithms exist which allow many but not all non-deterministic content
models to be reduced automatically to equivalent deterministic models; see
Br√ºggemann-Klein 1991 <bibref ref="ABK"/>.</p>
		</inform-div1>
		<inform-div1 id="sec-guessing">
			<head>Autodetection of Character Encodings</head>
			<p>The XML encoding declaration functions as an internal label on each entity,
indicating which character encoding is in use. Before an XML processor can
read the internal label, however, it apparently has to know what character
encoding is in use &mdash; which is what the internal label is trying to indicate.
In the general case, this is a hopeless situation. It is not entirely hopeless
in XML, however, because XML limits the general case in two ways: each implementation
is assumed to support only a finite set of character encodings, and the XML
encoding declaration is restricted in position and content in order to make
it feasible to autodetect the character encoding in use in each entity in
normal cases. Also, in many cases other sources of information are available
in addition to the XML data stream itself. Two cases may be distinguished,
depending on whether the XML entity is presented to the processor without,
or with, any accompanying (external) information. We consider the first case
first.</p>
			<div2 id="sec-guessing-no-ext-info">
				<head>Detection Without External Encoding Information</head>
				<p>Because each XML entity not accompanied by external
encoding information and not in UTF-8 or UTF-16 encoding must
begin with an XML encoding declaration, in which the first characters must
be '<code>&lt;?xml</code>', any conforming processor can detect, after two
to four octets of input, which of the following cases apply. In reading this
list, it may help to know that in UCS-4, '&lt;' is <quote><code>#x0000003C</code></quote>
and '?' is <quote><code>#x0000003F</code></quote>, and the Byte Order Mark
required of UTF-16 data streams is <quote><code>#xFEFF</code></quote>. The notation
<var>##</var> is used to denote any byte value except that two consecutive
<var>##</var>s cannot be both 00.</p>
				<p>With a Byte Order Mark:</p>
				<table border="1" frame="border" summary="Encoding detection summary">
					<tbody>
						<tr>
							<td>
								<code>00 00 FE
FF</code>
							</td>
							<td>UCS-4, big-endian machine (1234 order)</td>
						</tr>
						<tr>
							<td>
								<code>FF
FE 00 00</code>
							</td>
							<td>UCS-4, little-endian machine (4321 order)</td>
						</tr>
						<tr>
							<td>
								<code>00 00 FF FE</code>
							</td>
							<td>UCS-4, unusual octet order (2143)</td>
						</tr>
						<tr>
							<td>
								<code>FE FF 00 00</code>
							</td>
							<td>UCS-4, unusual octet order (3412)</td>
						</tr>
						<tr>
							<td>
								<code>FE FF ## ##</code>
							</td>
							<td>UTF-16, big-endian</td>
						</tr>
						<tr>
							<td>
								<code>FF FE ## ##</code>
							</td>
							<td>UTF-16, little-endian</td>
						</tr>
						<tr>
							<td>
								<code>EF BB BF</code>
							</td>
							<td>UTF-8</td>
						</tr>
					</tbody>
				</table>
				<p>Without a Byte Order Mark:</p>
				<table border="1" frame="border" summary="Encoding detection summary">
					<tbody>
						<tr>
							<td>
								<code>00&nbsp;00&nbsp;00&nbsp;3C</code>
							</td>
							<td rowspan="4">UCS-4 or other encoding with a 32-bit code unit and ASCII
characters encoded as ASCII values, in respectively big-endian (1234), little-endian
(4321) and two unusual byte orders (2143 and 3412). The encoding declaration
must be read to determine which of UCS-4 or other supported 32-bit encodings
applies.</td>
						</tr>
						<tr>
							<td>
								<code>3C 00 00 00</code>
							</td>
							<!--<td>UCS-4, little-endian machine (4321 order)</td>-->
						</tr>
						<tr>
							<td>
								<code>00 00 3C 00</code>
							</td>
							<!--<td>UCS-4, unusual octet order (2143)</td>-->
						</tr>
						<tr>
							<td>
								<code>00 3C 00 00</code>
							</td>
							<!--<td>UCS-4, unusual octet order (3412)</td>-->
						</tr>
						<tr>
							<td>
								<code>00 3C 00 3F</code>
							</td>
							<td>UTF-16BE or big-endian ISO-10646-UCS-2
or other encoding with a 16-bit code unit in big-endian order and ASCII characters
encoded as ASCII values (the encoding declaration must be read to determine
which)</td>
						</tr>
						<tr>
							<td>
								<code>3C 00 3F 00</code>
							</td>
							<td>UTF-16LE or little-endian
ISO-10646-UCS-2 or other encoding with a 16-bit code unit in little-endian
order and ASCII characters encoded as ASCII values (the encoding declaration
must be read to determine which)</td>
						</tr>
						<tr>
							<td>
								<code>3C 3F 78 6D</code>
							</td>
							<td>UTF-8, ISO 646, ASCII, some part of ISO 8859, Shift-JIS, EUC, or any other
7-bit, 8-bit, or mixed-width encoding which ensures that the characters of
ASCII have their normal positions, width, and values; the actual encoding
declaration must be read to detect which of these applies, but since all of
these encodings use the same bit patterns for the relevant ASCII characters,
the encoding declaration itself may be read reliably</td>
						</tr>
						<tr>
							<td>
								<code>4C
6F A7 94</code>
							</td>
							<td>EBCDIC (in some flavor; the full encoding declaration
must be read to tell which code page is in use)</td>
						</tr>
						<tr>
							<td>Other</td>
							<td>UTF-8 without an encoding declaration, or else the data stream is mislabeled
(lacking a required encoding declaration), corrupt, fragmentary, or enclosed
in a wrapper of some kind</td>
						</tr>
					</tbody>
				</table>
				<note>
					<p>In cases above which do not require reading the encoding declaration to
determine the encoding, section 4.3.3 still requires that the encoding declaration,
if present, be read and that the encoding name be checked to match the actual
encoding of the entity. Also, it is possible that new character encodings
will be invented that will make it necessary to use the encoding declaration
to determine the encoding, in cases where this is not required at present.</p>
				</note>
				<p>This level of autodetection is enough to read the XML encoding declaration
and parse the character-encoding identifier, which is still necessary to distinguish
the individual members of each family of encodings (e.g. to tell UTF-8 from
8859, and the parts of 8859 from each other, or to distinguish the specific
EBCDIC code page in use, and so on).</p>
				<p>Because the contents of the encoding declaration are restricted to characters
from the ASCII repertoire (however encoded),
a processor can reliably read the entire encoding declaration as soon as it
has detected which family of encodings is in use. Since in practice, all widely
used character encodings fall into one of the categories above, the XML encoding
declaration allows reasonably reliable in-band labeling of character encodings,
even when external sources of information at the operating-system or transport-protocol
level are unreliable. Character encodings such as UTF-7
that make overloaded usage of ASCII-valued bytes may fail to be reliably detected.</p>
				<p>Once the processor has detected the character encoding in use, it can act
appropriately, whether by invoking a separate input routine for each case,
or by calling the proper conversion function on each character of input.</p>
				<p>Like any self-labeling system, the XML encoding declaration will not work
if any software changes the entity's character set or encoding without updating
the encoding declaration. Implementors of character-encoding routines should
be careful to ensure the accuracy of the internal and external information
used to label the entity.</p>
			</div2>
			<div2 id="sec-guessing-with-ext-info">
				<head>Priorities in the Presence of External Encoding Information</head>
				<p>The second possible case occurs when the XML entity is accompanied by encoding
information, as in some file systems and some network protocols. When multiple
sources of information are available, their relative priority and the preferred
method of handling conflict should be specified as part of the higher-level
protocol used to deliver XML. In particular, please refer
to <bibref ref="rfc2376"/> or its successor, which defines the <code>text/xml</code>
and <code>application/xml</code> MIME types and provides some useful guidance.
In the interests of interoperability, however, the following rule is recommended.</p>
				<ulist>
					<item>
						<p>If an XML entity is in a file, the Byte-Order Mark and encoding declaration are used
(if present) to determine the character encoding.</p>
					</item>
				</ulist>
			</div2>
		</inform-div1>
		<inform-div1 id="sec-xml-wg">
			<head>W3C XML Working Group</head>
			<p>This specification was prepared and approved for publication by the W3C
XML Working Group (WG). WG approval of this specification does not necessarily
imply that all WG participants voted for its approval. The current and former members
in the XML WG are:</p>
			<orglist>
				<member>
					<name>Jon Bosak</name>
					<affiliation>Sun</affiliation>
					<role>Chair</role>
				</member>
				<member>
					<name>James Clark</name>
					<role>Technical Lead</role>
				</member>
				<member>
					<name>Tim Bray</name>
					<affiliation>Textuality and Netscape</affiliation>
					<role>XML Co-editor</role>
				</member>
				<member>
					<name>Jean Paoli</name>
					<affiliation>Microsoft</affiliation>
					<role>XML
Co-editor</role>
				</member>
				<member>
					<name>C. M. Sperberg-McQueen</name>
					<affiliation>U. of Ill.</affiliation>
					<role>XML Co-editor</role>
				</member>
				<member>
					<name>Dan Connolly</name>
					<affiliation>W3C</affiliation>
					<role>W3C Liaison</role>
				</member>
				<member>
					<name>Paula Angerstein</name>
					<affiliation>Texcel</affiliation>
				</member>
				<member>
					<name>Steve DeRose</name>
					<affiliation>INSO</affiliation>
				</member>
				<member>
					<name>Dave Hollander</name>
					<affiliation>HP</affiliation>
				</member>
				<member>
					<name>Eliot Kimber</name>
					<affiliation>ISOGEN</affiliation>
				</member>
				<member>
					<name>Eve Maler</name>
					<affiliation>ArborText</affiliation>
				</member>
				<member>
					<name>Tom Magliery</name>
					<affiliation>NCSA</affiliation>
				</member>
				<member>
					<name>Murray Maloney</name>
					<affiliation>SoftQuad, Grif
SA, Muzmo and Veo Systems</affiliation>
				</member>
				<member>
					<name>MURATA Makoto (FAMILY Given)</name>
					<affiliation>Fuji
Xerox Information Systems</affiliation>
				</member>
				<member>
					<name>Joel Nava</name>
					<affiliation>Adobe</affiliation>
				</member>
				<member>
					<name>Conleth O'Connell</name>
					<affiliation>Vignette</affiliation>
				</member>
				<member>
					<name>Peter Sharpe</name>
					<affiliation>SoftQuad</affiliation>
				</member>
				<member>
					<name>John Tigue</name>
					<affiliation>DataChannel</affiliation>
				</member>
			</orglist>
		</inform-div1>
		<inform-div1 id="sec-core-wg">
			<head>W3C XML Core Working Group</head>
			<p>The <phrase diff="chg">second</phrase> edition of this specification was prepared by the W3C XML Core
Working Group (WG). The participants in the WG at the time of publication of this
edition were:</p>
			<orglist>
				<member>
					<name>Leonid Arbouzov</name>
					<affiliation>Sun Microsystems</affiliation>
				</member>
				<member>
					<name>John Cowan</name>
				</member>
				<member>
					<name>Andrew Fang</name>
					<affiliation>PTC-Arbortext</affiliation>
				</member>
				<member>
					<name>Paul Grosso</name>
					<affiliation>PTC-Arbortext</affiliation>
					<role>Co-Chair</role>
				</member>
				<member>
					<name>Konrad Lanz</name>
					<affiliation>A-SIT</affiliation>
				</member>
				<member>
					<name>Philippe Le H√©garet</name>
					<affiliation>W3C</affiliation>
					<role>Staff Contact</role>
				</member>
				<member>
					<name>Glenn Marcy</name>
					<affiliation>IBM</affiliation>
				</member>
				<member>
					<name>Sandra Martinez</name>
					<affiliation>NIST</affiliation>
				</member>
				<member>
					<name>Ravindrakumar R</name>
					<affiliation>CDAC</affiliation>
				</member>
				<member>
					<name>Lew Shannon</name>
				</member>
				<member>
					<name>Henry Thompson</name>
					<affiliation>W3C</affiliation>
					<role>Staff Contact</role>
				</member>
				<member>
					<name>Richard Tobin</name>
					<affiliation>University of Edinburgh</affiliation>
				</member>
				<member>
					<name>Daniel Veillard</name>
				</member>
				<member>
					<name>Norman Walsh</name>
					<affiliation>Sun Microsystems</affiliation>
					<role>Co-Chair</role>
				</member>
				<member>
					<name>Fran√ßois Yergeau</name>
				</member>
			</orglist>
		</inform-div1>
		<inform-div1 id="prod-notes">
			<head>Production Notes</head>
			<p>This edition was encoded in a
slightly modified version of the
<loc href="http://www.w3.org/2002/xmlspec/dtd/2.10/xmlspec.dtd">XMLspec DTD, 2.10</loc>.
The XHTML versions were produced with a combination of the
<loc href="http://www.w3.org/2002/xmlspec/xhtml/1.13/xmlspec.xsl">xmlspec.xsl</loc>,
<loc href="http://www.w3.org/2002/xmlspec/xhtml/1.13/diffspec.xsl">diffspec.xsl</loc>,
and <loc href="REC-xml.xsl">REC-xml.xsl</loc>
XSLT stylesheets.</p>
		</inform-div1>
		<inform-div1 id="sec-suggested-names">
			<head>Suggestions for XML Names</head>
			<p>The following suggestions define what is believed to be best
practice in the construction of XML names used as element names,
attribute names, processing instruction targets, entity names,
notation names, and the values of attributes of type ID, and are
intended as guidance for document authors and schema designers.
All references to Unicode are understood with respect to
a particular version of the Unicode Standard greater than or equal
to 3.0; which version should be used is left to the discretion of
the document author or schema designer.</p>
			<p>The first two suggestions are directly derived from the rules
given for identifiers in the Unicode Standard, version 3.0, and
exclude all control characters, enclosing nonspacing marks,
non-decimal numbers, private-use characters, punctuation characters
(with the noted exceptions), symbol characters, unassigned
codepoints, and white space characters. The other suggestions
are mostly derived from <bibref ref="XML1.0"/> Appendix B.</p>
			<olist>
				<item>
					<p>The first character of any name should have a Unicode General
Category of Ll, Lu, Lo, Lm, Lt, or Nl, or else be '_' #x5F.</p>
				</item>
				<item>
					<p>Characters other than the first should have a Unicode General
Category of Ll, Lu, Lo, Lm, Lt, Mc, Mn, Nl, Nd, Pc, or Cf, or else
be one of the following: '-' #x2D, '.' #x2E, ':' #x3A or
'¬∑' #xB7 (middle dot). Since Cf characters are not
directly visible, they should be employed with caution and only
when necessary, to avoid creating names which are distinct to XML
processors but look the same to human beings.</p>
				</item>
				<item>
					<p>Ideographic characters which have a canonical decomposition
(including those in the ranges [#xF900-#xFAFF] and
[#x2F800-#x2FFFD], with 12 exceptions) should not be used in names.
</p>
				</item>
				<item>
					<p>Characters which have a compatibility decomposition (those with
a "compatibility formatting tag" in field 5 of the Unicode
Character Database -- marked by field 5 beginning with a "&lt;")
should not be used in names.  This suggestion does not apply
to #x0E33 THAI CHARACTER SARA AM or #x0EB3 LAO CHARACTER AM, which
despite their compatibility decompositions are in regular use in
those scripts.</p>
				</item>
				<item>
					<p>Combining characters meant for use with symbols only (including
those in the ranges [#x20D0-#x20EF] and [#x1D165-#x1D1AD]) should
not be used in names.</p>
				</item>
				<item>
					<p>The interlinear annotation characters ([#xFFF9-#xFFFB<phrase diff="add">
							<loc role="erratumref" href="E07"/>]</phrase>) should
not be used in names.</p>
				</item>
				<item>
					<p>Variation selector characters should not be used in names.</p>
				</item>
				<item>
					<p>Names which are nonsensical, unpronounceable, hard to read, or
easily confusable with other names should not be employed.</p>
				</item>
			</olist>
		</inform-div1>
	</back>
</spec>
